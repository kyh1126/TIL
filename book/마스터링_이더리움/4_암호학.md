# Chapter 4. 암호학


## 1. 암호학

- 이더리움의 기반 기술 중 하나로 컴퓨터 보안에 광범위하게 사용되는 수학의 한 분야
    - 비밀을 밝히지 않고 비밀 지식 증명[디지털서명]
    - 데이터 진위성 증명[해시]
- `이더리움 프로토콜 암호화 안되어 있음`
    - 플랫폼 ←→ 노드 데이터[트랜잭션포함] 누구나 볼 수 있음
    - 고급 암호화 도구[영지식증명, 동형암호화] 제공 준비 완료[미반영]
- 이더리움 `공개키 암호화[Public Key Crypotography, PKC]` 방식 사용


## 2. 키와 주소

- 이더리움 계정 유형
    - `외부 소유 계정`[Externally Owned Account, EOA]
        - 디지털 개인키[Private key], 이더리움 주소[Ethereum address], 디지털 서명[Digital signature]을 통해 외부 소유 계정의 이더 소유권 확립
        - 개인키: 모든사용자 ←→ 이더리움 상호작용 핵심
        - 계정주소: 개인키로부터 파생
        - 개인키는 계정[Account]이라고도 불리는 단일 이더리움 주소를 고유하게 결정
    - `컨트랙트`[Contract]
        - 개인키로 뒷받침되지 않음
- 개인키
    - 이더리움에 전송 또는 저장하지 않음
    - 비공개로 유지[오프라인 보관 추천]
    - `소유자는 누구나 해당 계정과 계정이 가진 이더를 제어 가능`
- 이더리움의 기반 암호화 시스템
    - 공개키 암호화 시스템
        - 공개키: 은행 계좌 번호
            - 계정 식별 가능
        - 개인키: PIN번호
            - 이더리움 사용자에게 드러는경우가 거의 없고, 암호화된 형태로 지갑 소프트웨어로 관리


## 3. 공개키 암호화와 암호화폐

- 공개키 암호화[Public Key Crypotography]
    - 비대칭 암호화라고도 하며 오늘날 정보 보안의 핵심
    - 1970년대 마틴 핼먼[Martin Hellman], 휫필드 디피[Whitfield DIffie], 랄프 머클[Ralph Merkle]이 처음 공개
    - 역계산이 어려운 특수한 속성을 가지는 함수를 바탕으로 하는 키를 사용하여 정보를 보호
- 트랩 도어 함수[Trapdoor function]
    - 일부 정보를 알고 있을때 쉽게 역산하여 나머지 값들을 찾아낼 수 있는 함수
        - 예) 큰 두 소수[1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수] 곱의 결과로 부터 두 소수 찾기
    - WIKI

        ```
        트랩도어 함수(trapdoor function,비밀통로 일방향함수)는 일방향함수의 한 종류이다. 보통 일방향함수처럼 함수의 역을 구하는 것은 어렵지만, 트랩도어라고 부르는 특수한 정보가 있으면 쉽게 역을 구할 수 있는 함수이다. 트랩도어 함수는 암호학 분야에서 널리 사용한다.

        트랩도어 함수를 수학적으로 정의하면 다음과 같다. 어떤 비밀값 y가 있어서, 어떤 x에 대해서 y가 없을 때는 f(x)를 구하기 어렵지만 y가 주어진다면 f(x)에서 x 값을 쉽게 찾을 수 있다면 함수 f는 트랩도어 함수이다.

        1970년대에 휘트필드 디피, 마틴 헬만, 랄프 머클등이 비대칭 암호에 대해 연구하면서, 트랩도어 함수가 주목 받기 시작했다. 실제로 1976년에 디피와 헬만이 '트랩도어 함수'라는 이름을 지었다. 몇 가지 함수들이 트랩도어 함수라고 추측했으나, 예상외로 트랩도어의 성질을 온전히 만족하는 함수를 찾기 어려웠다. 예를 들어 부분집합의 합 문제를 이용한 트랩도어 함수의 경우, 트랩도어 없이도 역을 구할 수 있기 때문에 부분집합의 합 문제로는 트랩도어 함수를 만들 수 없다.

        현재까지 가장 널리 알려진 트랩도어 함수의 후보는 RSA와 라빈 함수들이다. 이 함수들 모두 합성수에 대한 모듈로 거듭제곱(modulo exponentiation)을 사용하며, 소인수 분해의 어려움에 기반하고 있다.

        이산 로그 문제에 기반한 트랩도어 함수는 소수를 법으로 가지는 군에서나 타원곡선에서나 모두 알려진 것이 없다. 아직까지 이산 로그를 효율적으로 계산할 수 있는 트랩도어를 찾지 못했기 때문이다. 그럼에도 불구하고, ElGamal 암호체계나 DSA등은 이산 로그 문제의 어려움에 기반하고 있다.
        ```

- 타원 곡선 암호화[Elliptic curve cryptography]
    - 트랩도어가 없는 역산 불가능 문제: 이산 로그 문제[Discrete logarithm problem]
    - 컴퓨터 시스템에서 광범위하게 활용
    - 이더리움에서 개인키와 디지털 서명을 사용하는 기초
- 이더리움에서의 공개키 암호화
    - `공개키-개인키 쌍`[공개키는 개인키로부터 파생]을 생성
        - 공개키-개인키 쌍
            - 계정 주소
            - 계정의 이더에 대한 접근 권한
            - 스마트컨트랙트 사용시 계정이 필요로 하는 모든 인증에 대한 제어권
            - 이더리움 계정을 나타냄
    - (메세지 += 개인키 += 디지털서명) = 트랜젝션 → 이더리움 네트워크 → 누구나 유효성 확인 가능
    - 지갑 구현시 일반적으로 공개키-개인키 쌍으로 저장하나 공개키는 개인키로부터 간단히 계산 될 수 있으므로 개인키만 저장도 가능


## 4. 개인키

- 모든 이더리움상 소유권과 제어의 핵심
- 항상 비밀로 유지
- 잃어버리면 되찾을 수 없으며, 해당 키로 확보한 자금도 영원히 소실
- 개인키 → 공개키 → 이더리움 주소
- 디지털 서명을 만드는 데 필요한 고유 정보의 접근 제어
- 디지털 서명 → 소유자 또는 컨트랙트 사용자 인증에도 사용
- 난수로 개인키 생성
    - 무작위성[엔트로피]이 확보된 1 ~ 2$^{256}$사이의 숫자 선택[2$^{256}$ = 10$^{77}$]
    - Keccak-256, SHA-256 알고리즘 사용
    - 일반 rand 사용 비추
    - 충분한 엔트로피 원천의 시드(seed) + 암호로 안전한 의사난수 생성기 사용[예: CSPRNG]


## 5. 공개키

- K[공개키] = k[개인키] * G[생성자점: 타원곡선(secp256k1)위의 임의의 점]
- *: 특수 타원 곡선 곱하기

    ![Untitled 8.png](masteringethereum/Untitled%208.png)

- 타원 곡선 곱셈 = 단방향 함수 유형
- 한방향[곱하기]는 수행하기 쉽고 반대방향[나누기]는 수행하기가 쉽지 않다.

### 타원 곡선 암호화 설명 및 공개키 생성

---

![Untitled 9.png](masteringethereum/Untitled%209.png)

미국 표준기술연구소[NIST]에서 제정한 secp256k1 타원 곡선

- K = k * G → G + G + G + G + ... + G(k번 반복)
    1. 임의의 점 G에서 시작[`시작점은 모두 동일`] G에서 접선을 그어 만나는 다른 접점[-2G]
    2. -2G의 x축 대칭 점
    3. 1, 2 과정을 k번 크기 만큼 반복하여 K[공개키] 생성

    ```python
    p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
    x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
    y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
    (x ** 3 + 7 - y**2) % p
    ```

  ![Untitled 10.png](masteringethereum/Untitled%2010.png)

- 생성자점 G는 secp256k1 표준의 일부로 지정
- G는 모든 이더리움 사용자에 대해 항상 동일, 따라서 G와 개인키 k를 곱한 결과는 항상 공개키 K로 동일
- 개인키는 공개키로 변환 가능하지만 공개키는 개인키로 변환 불가
- 이더리움은 압축되지 않은 공개키만 사용 따라서 모든 공개키의 접두어는 04로 시작

    ```
    K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G

    K = (x, y)

    x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
    y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0

    04 + x좌표 + y좌표

    046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
    ```

### 타원 곡선 라이브러리

---

- secp256k1 타원 곡선을 구현한 라이브러리
    - OpenSSL
    - libsecp256k1[OpenSSL 대체를 위해 새로작성, 성능과 보안 모두 뛰어남]


## 6. 암호화 해시 함수

> 임의 크기의 데이터를 고정된 크기의 데이터로 매핑하는 데 사용 할 수 있는 모든 함수

- 해시 함수는 이더리움뿐만 아닌 모든 암호학적 시스템에 광범위하게 사용
- 이더리움 공개키 → 주소로 변환시 일부로 사용
- 단방향 특성 → 결과 해시로 부터 원래 메세지 작성 불가[유일한 방법 무차별 대입]
- 다대일 함수[hash collision]
    - A → hash func(A) → B
    - C → hash func(C) → B
    - 해시 함수 = 해시 충돌 발생 확율 낮음
- 암호화 해시 함수 속성
    - 결정론
        - 동일 메세지 = 동일 결과
    - 검증성
        - 메세지 해시 계산은 효율적[선형 복잡성]
    - 비상관성
        - 작은 메세지 변화 → 완전 다른 해시 결과
    - 비가역성
        - 역산 불가
    - 충돌방지
        - 같은 해시를 생성하는 2개의 메세지간 상관관계 없음
- 암호화 해시 함수 속성이 사용되는 보안 애플리케이션
    - 데이터핑커프린팅
    - 메시지 무결성(오류 감지)
    - 작업증명
    - 인증(암호 해싱 및 키 스트레칭)
    - 의사 난수 생성기
    - 메시지 커밋(커밋-공개 메커니즘)
    - 고유 식별자

### 이더리움의 암호화 해시 함수: Keccak-256

---

> 이더리움: Keccak-256 암호화 해시 함수 사용

- SHA-3 암호화 해시 함수 경쟁 대회 우승 알고리즘
- SHA-3 표준 제정에 미국 국가안보국 개입 백도어 삽입 의혹으로 원 Keccak-256을 사용
- SHA-3 와 Keccak-256 구별 방법
    - 빈입력

        ```python
        Python 3.9.4 (tags/v3.9.4:1f2e308, Apr  6 2021, 13:22:44) [MSC v.1928 32 bit (Intel)] on win32
        Type "help", "copyright", "credits" or "license" for more information.
        >>> import hashlib
        >>> sha3_test = hashlib.sha3_256()
        >>> sha3_test.update(b'')
        >>> sha3_test.hexdigest()
        'a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a'
        >>>

        Python 3.9.4 (tags/v3.9.4:1f2e308, Apr  6 2021, 13:22:44) [MSC v.1928 32 bit (Intel)] on win32
        Type "help", "copyright", "credits" or "license" for more information.
        >>> from Crypto.Hash import keccak
        >>> k = keccak.new(digest_bits=256)
        >>> k = k.update(b'')
        >>> k.hexdigest()
        'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'
        >>>
        ```


## 7. 이더리움 주소

> 이더리움 주소는 Keccak-256 단방향 해시 함수를 사용하는 공개키 또는 컨트랙트에서 파생한 고유 식별자(Unique identifier)

```python
>>> from eth_keys import keys
>>> from eth_utils import decode_hex
>>> priv_key_bytes = decode_hex('0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315')
>>> priv_key = keys.PrivateKey(priv_key_bytes)
>>> pub_key = priv_key.public_key
>>> pub_key.to_hex()
'0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0'
>>> pub_key.to_checksum_address()
'0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9'
```

### 이더리움 주소 형식

---

- 16진수이며, 공개키 Keccak-256 해시의 마지막 20바이트
- 이더리움 주소는 체크섬이 없음 → 초기에 주소 및 입력 유효성 오류로 자금 손실 등 문제 발생

### 이더리움 주소 인코딩 옵션

---

- 클라이언트 주소 상호교환 프로토콜
- 대문자 16진수 인코딩된 체크섬(EIP-55)


## 8. 결론

- 이더리움에서의 공개키 및 개인키 사용과 해시 함수 암호화 도구를 사용하여 주소를 만들고 검증 해보았다.
- 디지털 서명과 개인키를 공개하지 않고 개인키의 소유권을 입증 할 수 있는 방법에 대해 살펴봤다.


- [Notion link](https://www.notion.so/Chapter-4-0e1a40a3c1d9456284918c87faa14f6f)
