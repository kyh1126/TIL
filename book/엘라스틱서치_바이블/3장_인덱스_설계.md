# 3장. 인덱스 설계

# 3.1 인덱스 설정

---

- 인덱스를 생성할 때에는 인덱스의 동작에 관한 설정을 지정할 수 있다.
- 인덱스 설정을 조회하려면 인덱스 이름 뒤에 `/_settings`를 넣어 GET 메서드로 호출한다.
    
    ```powershell
    GET [인덱스 이름]/_settings
    ```
    

- 기존에 존재하지 않는 인덱스에 문서 색인 요청을 하면 엘라스틱서치는 인덱스를 자동으로 생성한다.
    
    ```json
    {
      "my_index": {
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "**number_of_shards**": "1",
            "provided_name": "my_index",
            "creation_date": "1705138019350",
            "**number_of_replicas**": "1",
            "uuid": "6FYtFWOsQxK19uQzq3bO1A",
            "version": {
              "created": "8500003"
            }
          }
        }
      }
    }
    ```
    
    - number_of_shards와 number_of_replicas 값에 주목하자.
    - 이 응답에 명시적으로 포함되지는 않았지만 refresh_interval이라는 중요한 설정이 있다.

## 3.1.1 number_of_shards

---

- number_of_shards: 이 인덱스가 데이터를 몇 개의 샤드로 쪼갤 것인지 지정하는 값
    - 한 번 지정하면 reindex 같은 동작을 통해 인덱스를 통째로 재색인하는 등 특별한 작업을 수행하지 않는 한 바꿀 수 없다.

- 샤드 개수를 어떻게 지정하느냐는 엘라스틱서치 클러스터 전체의 성능에도 큰 영향을 미친다.
    - 샤드 하나마다 루씬 인덱스가 하나씩 더 생성된다.
    - 주 샤드 하나당 복제본 샤드도 늘어난다.

- number_of_shards 설정의 기본값
    - 7 버전부터 1로 변경됐다.
    - 7 버전 미만까지는 5였다.

## 3.1.2 number_of_replicas

---

- number_of_replicas: 주 샤드 하나당 복제본 샤드를 몇 개 둘 것인지를 지정하는 설정
    - 이 값은 인덱스 생성 후에도 동적으로 변경할 수 있다.
        
        ```json
        PUT [인덱스 이름]/_settings
        {
          [변경할 내용]
        }
        ```
        

- ex> number_of_replicas 값을 0으로 동적 업데이트 하는 호출
    
    ```json
    // request
    PUT my_index/_settings
    {
      "index.number_of_replicas": 0
    }
    
    // response
    {
      "acknowledged": true
    }
    ```
    
    - 0으로 지정하면 복제본 샤드를 생성하지 않고 주 샤드만 둔다.
    
    → 복제본 샤드를 생성하지 않는 설정은 주로 대용량의 초기 데이터를 마이그레이션하는 등의 시나리오에서 쓰기 성능을 일시적으로 끌어올리기 위해 사용한다.
    

## 3.1.3 refresh_interval

---

- refresh_interval: 엘라스틱서치가 해당 인덱스를 대상으로 refresh를 얼마나 자주 수행할 것인지를 지정한다.
    - 엘라스틱서치 인덱스에 색인된 문서는 refresh되어야 검색 대상이 되기 때문에 중요한 설정이다.
    
    ```json
    PUT my_index/_settings
    {
      "index.refresh_interval": "1s"
    }
    ```
    
    - 이 값을 -1로 지정하면 주기적 refresh를 수행하지 않는다.

- 이 값을 명시적으로 설정하지 않으면 매 1초마다 refresh를 수행하며, 마지막으로 검색 쿼리가 들어온 시각을 확인한다.
    - 30초 이상 검색 쿼리가 들어오지 않는 것을 확인하면 다음 첫 검색 쿼리가 들어올 때가지 refresh를 수행하지 않는다.
        - 30초 대기 시간은 `index.search.idle.after` 설정에서 변경할 수 있다.
    - 값을 설정하지 않은 상태로 돌리려면 `null`로 업데이트하면 된다.

## 3.1.4 인덱스 설정을 지정하여 인덱스 생성

---

- 인덱스가 없을 때 문서 색인을 요청하여 자동으로 생성된 인덱스
    
    → 주요 인덱스 설정은 모두 기본값이 지정된다. 실제 환경에서는 이러한 방식의 운영은 적절하지 않다.
    

- 수동으로 인덱스를 생성, 기본 설정값으로 인덱스 생성
    
    ```json
    PUT [인덱스 이름]
    ```
    
    ```json
    // request
    PUT my_index2
    
    // response
    {
      "acknowledged": true,
      "shards_acknowledged": true,
      "index": "my_index2"
    }
    ```
    
    - `acknowledged`: 해당 인덱스가 클러스터에 제대로 생성되었는지 여부를 나타낸다.
        - 클러스터 상태 업데이트가 타임아웃이 떨어지기 전에 성공했는지 여부를 의미한다.
    - `shards_acknowledged`: 타임아웃이 떨어지기 전에 지정한 개수만큼 샤드가 활성화됐는지를 나타낸다.
        - 인덱스 생성 시에 `wait_for_active_shards` 인자로 해당 개수를 지정할 수 있다.
            - 기본적으로는 1개의 샤드, 즉 주 샤드가 시간 안에 활성화되면 `true`를 반환한다.
    
    → 타임아웃 전에 해당하는 작업이 완료되었는지를 나타낼 뿐
    

- 인덱스 삭제
    
    ```json
    DELETE [인덱스 이름]
    ```
    
    ```json
    // request
    DELETE my_index2
    
    // response
    {
      "acknowledged": true
    }
    ```
    

- 요청 본문에 설정을 직접 지정하여 인덱스를 생성할 수 있다.
    
    ```json
    PUT [인덱스 이름]
    {
      "settings": {
        [인덱스 설정]
      }
    }
    ```
    
    ```json
    // request
    PUT my_index2
    {
      "settings": {
        "number_of_shards": 2,
        "number_of_replicas": 2
      }
    }
    
    // response
    {
      "acknowledged": true,
      "shards_acknowledged": true,
      "index": "my_index2"
    }
    ```
    
- 설정이 제대로 적용되었는지 확인
    
    ```json
    GET [인덱스 이름]
    ```
    
    ```json
    // request
    GET my_index2
    
    // response
    {
      "my_index2": {
        "aliases": {},
        "mappings": {},
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "**number_of_shards**": "2",
            "provided_name": "my_index2",
            "creation_date": "1705139839056",
            "**number_of_replicas**": "2",
            "uuid": "dWSk3IVWQfKzr8uErjID-A",
            "version": {
              "created": "8500003"
            }
          }
        }
      }
    }
    ```
    
    - settings 항목 밑으로 보이는 인덱스 설정 외에도 `mappings`라는 항목을 확인할 수 있다.
    - 이곳에는 인덱스 설계의 핵심인 매핑과 필드 타입에 관한 정보가 들어간다.

# 3.2 매핑과 필드 타입

---

- 매핑은 문서가 인덱스에 어떻게 색인되고 저장되는지 정의하는 부분이다.
    - JSON 문서의 각 필드를 어떤 방식으로 분석하고 색인할지, 어떤 타입으로 저장할지 등을 세부적으로 지정할 수 있다.

- ex> my_index2 인덱스에 문서를 하나 색인하고 인덱스 정보를 확인해보자.
    
    ```json
    // request
    PUT my_index2/_doc/1
    {
      "title": "hello world",
      "views": 1234,
      "public": true,
      "point": 4.5,
      "created": "2019-01-17T14:05:01.234Z"
    }
    
    // response
    {
      "_index": "my_index2",
      "_id": "1",
      "_version": 1,
      "result": "created",
      "_shards": {
        "total": 3,
        "successful": 1,
        "failed": 0
      },
      "_seq_no": 0,
      "_primary_term": 1
    }
    ```
    
    ```json
    // request
    GET my_index2
    
    // response
    // 동적 매핑
    {
      "my_index2": {
        "aliases": {},
        "mappings": {
          "properties": {
            "created": {
              "type": "date"
            },
            "point": {
              "type": "float"
            },
            "public": {
              "type": "boolean"
            },
            "title": {
              "type": "text",
              "fields": {
                "keyword": {
                  "type": "keyword",
                  "ignore_above": 256
                }
              }
            },
            "views": {
              "type": "long"
            }
          }
        },
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "number_of_shards": "2",
            "provided_name": "my_index2",
            "creation_date": "1705139839056",
            "number_of_replicas": "2",
            "uuid": "dWSk3IVWQfKzr8uErjID-A",
            "version": {
              "created": "8500003"
            }
          }
        }
      }
    }
    ```
    
    - `mappings` 항목 밑에 각 필드의 타입과 관련된 정보가 새로 생긴 것을 확인할 수 있다.

## 3.2.1 동적 매핑 vs 명시적 매핑

---

- 인덱스를 생성할 때 직접 매핑 정보를 명시적으로 지정
    
    ```json
    PUT mapping_test
    {
      "mappings": {
        "properties": {
          "createdDate": {
            "type": "date",
            "format": "strict_date_time || epoch_millis"
          },
          "keywordString": {
            "type": "keyword"
          },
          "textString": {
            "type": "text"
          }
        }
      },
      "settings": {
        "number_of_replicas": 1,
        "number_of_shards": 1
      }
    }
    ```
    
    - 필드 타입을 포함한 매핑 설정 내 대부분의 내용은 한 번 지정되면 사실상 변경이 불가능하다.

- 동적 매핑은 예기치 않은 신규 필드가 포함된 데이터 인입 등의 상황에 있어 유연한 운영을 가능하게 해 준다.
    - 하지만 신규 필드 추가가 예정돼 있다면 동적 매핑에 기대지 말고 명시적으로 매핑을 지정하는 것이 좋다.

- 이미 인덱스가 생성된 경우에도 신규 필드를 추가할 때에는 매핑 정보를 추가할 수 있다.
    
    ```json
    PUT mapping_test/_mapping
    {
      "properties": {
        "longValue": {
          "type": "long"
        }
      }
    }
    ```
    
- 변경된 매핑 정보를 확인
    
    ```json
    // request
    GET mapping_test/_mapping
    
    // response
    {
      "mapping_test": {
        "mappings": {
          "properties": {
            "createdDate": {
              "type": "date",
              "format": "strict_date_time || epoch_millis"
            },
            "keywordString": {
              "type": "keyword"
            },
            "longValue": {
              "type": "long"
            },
            "textString": {
              "type": "text"
            }
          }
        }
      }
    }
    ```
    

## 3.2.2 필드 타입

---

- 필드 타입: 필드의 값이 어떤 형태로 저장될지를 지정한다. 한 번 지정되면 변경이 불가능하므로 매우 신중하게 지정해야 한다.
    
    
    | 분류 | 종류 |
    | --- | --- |
    | 심플 타입 | text, keyword, date, long, double, boolean, ip 등 |
    | 계층 구조를 지원하는 타입 | object, nested 등 |
    | 그 외 특수한 타입 | geo_point, geo_shape 등 |

### 심플 타입

---

- 심플 타입: 직관적으로 알기 쉬운 간단한 자료형

- 숫자타입
    
    
    | 종류 |  |
    | --- | --- |
    | long | 64비트 부호 있는 정수 (-2^63 ~ 2^63-1) |
    | integer | 32비트 부호 있는 정수 |
    | short | 16비트 부호 있는 정수 |
    | byte | 8비트 부호 있는 정수 |
    | double | 64비트 부동소수점 수 |
    | float | 32비트 부동소수점 수 |
    | half_float | 16비트 부동소수점 수 |
    | scaled_float | double 고정 환산 계수로 스케일링하여 long으로 저장되는 부동소수점 수 |
    | unsigned_long | unsigned 64비트 정수 (0 ~ 2^64-1) |
    - 정수형 데이터를 담는 필드라면 비즈니스 요건에 맞는 범위에서 가장 작은 비트를 사용하는 자료형을 고르면 된다.
        - 😃 작은 비트를 사용하는 자료형을 고르면 색인과 검색 시 이득이 있다.
        - 다만 저장할 때는 실제 값에 맞춰 최적화되기 때문에 디스크 사용량에는 이득이 없다.
            
            ![Untitled](./image/3/Untitled.png)
            
            - C언어 기준, `char`형(n1, n2) 덧셈결과로 반환값 크기는 1바이트, short형(n3, n4) 덧셈결과로 반환된 크기는 2바이트가 될 것 같지만 → 출력은 모두 4바이트를 보여준다.
            - ❗일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 `Int`로 정의한다.
                
                → `Int`형 연산 속도가 다른 자료형의 연산 속도에 비해서 동일하거나 더 빠르다.
                
            - 😃 `Int`형 연산이 CPU가 성능을 내기에 가장 좋은 연산이다 보니, 그보다 작은 크기의 데이터는 `Int`형으로 바꿔 연산이 진행된다.
    
    - 부동소수점 수를 담는 필드라면 환산 계수로 스케일링해서 정수로 저장하는 `scaled_float` 타입을 고려할 수 있다.
        - `scaling_factor`라는 환산 계수 인자를 지정해야 한다.
        - ex> `scaling_factor` 값이 100이고 실제 필드의 값이 3.943이라면 엘라스틱서치는 이를 394라는 정수로 색인한다.
            - 이후의 검색, 집계, 정렬 과정에서는 이 필드가 3.94 값을 가진 것처럼 동작한다.
            - 압축이 쉬워 디스크 공간에서 이득을 볼 수 있다.
    
    <aside>
    💡 숫자 identifiers 매핑 ([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html))
    
    - 만약 숫자 식별자를 `range` 쿼리로 검색할 일이 없을것 같다면 `keyword` 타입 사용을 고려해봐라.
        - `term` 쿼리는 종종 `numeric` 필드보다 `keyowrd` 필드를 더 빠르게 검색한다.
    </aside>
    
- date 타입
    - mapping_test 인덱스에 문서 두 개를 추가해 보자.
        
        ```json
        PUT mapping_test/_doc/1
        {
          "createdDate": "2020-09-03T02:41:32.001Z"
        }
        PUT mapping_test/_doc/2
        {
          "createdDate": 1599068514123 // 2020년 9월 3일 목요일 오전 2:41:54.123
        }
        ```
        
        ```json
        // request
        GET mapping_test/_search
        {
          "query": {
            "range": {
              "createdDate": {
                "gte": "2020-09-02T17:00:00.000Z",
                "lte": "2020-09-03T03:00:00.000Z"
              }
            }
          }
        }
        
        // response
        {
          "took": 2,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 2,
              "relation": "eq"
            },
            "max_score": 1,
            "hits": [
              {
                "_index": "mapping_test", // 책에 있는 "_type": "_doc" 없어짐
                "_id": "1",
                "_score": 1,
                "_source": {
                  "createdDate": "2020-09-03T02:41:32.001Z"
                }
              },
              {
                "_index": "mapping_test",
                "_id": "2",
                "_score": 1,
                "_source": {
                  "createdDate": 1599068514123
                }
              }
            ]
          }
        }
        ```
        
    - 엘라스틱서치의 `date` 타입은 인입되는 데이터의 형식을 `format`이라는 옵션으로 지정한다.
        - 문서가 어떤 형식으로 들어오더라도 엘라스틱서치 내부적으로는 UTC 시간대로 변환하는 과정을 거쳐 epoch milliseconds 형식의 long 숫자로 색인된다.
        - `format`에는 `java.time.format.DateTimeFormatter`로 인식 가능한 패턴을 사용할 수 있다.
            - 그 외에 다양한 빌트인 형식이 미리 갖춰져 있다.
            
            | 종류 | 설명 |
            | --- | --- |
            | epoch_millis | 밀리초 단위로 표현한 epoch 시간 |
            | epoch_second | 초 단위로 표현한 epoch 시간 |
            | date_time | yyyyMMdd 형태로 표현한 날짜 |
            | strict_date_time | yyyy-MM-dd’T’HH:mm:ss.SSSZ로 표현한 날짜와 시간 |
            | date_optional_time | 최소 연 단위의 날짜를 포함해야 하며, 선택적으로 시간 정보도 포함하여 ISO datetime 형태로 표현된 날짜와 시간
            ex> yyyy-MM-dd 또는 yyyy-MM-dd’T’HH:mm:ss.SSSZ |
            | strict_date_optional_time | date_optional_time과 동일하지만 연, 월, 일이 각각 4자리, 2자리, 2자리임을 보장해야 한다. |
        - 여러 형식을 허용하도록 지정하려면 `format`을 `||` 문자로 이어 붙이면 된다.
            - 기본값: `strict_date_optional_time || epoch_millis`

### 배열

---

- 엘라스틱서치에는 배열을 표현하는 별도의 타입 구분이 없다.
    - `long` 타입의 필드에는 309라는 단일 숫자 데이터를 넣을 수도 있고 [221, 309, 1599208568] 배열 데이터도 넣을 수 있다.

- ex> array_test 인덱스 생성을 완료한 후 해당 인덱스에 다음의 두 문서를 색인해 보자.
    
    ```json
    PUT array_test
    {
      "mappings": {
        "properties": {
          "longField": {
            "type": "long"
          },
          "keywordField": {
            "type": "keyword"
          }
        }
      }
    }
    ```
    
    ```json
    PUT array_test/_doc/1
    {
      "longField": 309,
      "keywordField": ["hello", "world"]
    }
    PUT array_test/_doc/2
    {
      "longField": [221, 309, 1599208568],
      "keywordField": "hello"
    }
    ```
    
    - 성공적으로 색인될 것이다.
- 그러나 여러 타입이 혼합된 배열 데이터의 색인을 요청하는 경우 색인은 실패한다.
    
    ```json
    // request
    PUT array_test/_doc/3
    {
      "longField": [221, "hello"]
    }
    
    // response
    {
      "error": {
        "root_cause": [
          {
            "type": "document_parsing_exception",
            "reason": "[2:22] failed to parse field [longField] of type [long] in document with id '3'. Preview of field's value: 'hello'"
          }
        ],
        "type": "document_parsing_exception",
        "reason": "[2:22] failed to parse field [longField] of type [long] in document with id '3'. Preview of field's value: 'hello'",
        "caused_by": {
          "type": "illegal_argument_exception",
          "reason": "For input string: \"hello\""
        }
      },
      "status": 400
    }
    ```
    

- `term` 쿼리: 문서 내 지정한 필드의 값이 질의한 값과 일치하는 문서를 검색하는 기본적인 쿼리
    
    ```json
    // request
    GET array_test/_search
    {
      "query": {
        "term": {
          "longField": 309
        }
      }
    }
    
    // response
    {
      "took": 1,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 2,
          "relation": "eq"
        },
        "max_score": 1,
        "hits": [
          {
            "_index": "array_test",
            "_id": "1",
            "_score": 1,
            "_source": {
              "longField": 309,
              "keywordField": [
                "hello",
                "world"
              ]
            }
          },
          {
            "_index": "array_test",
            "_id": "2",
            "_score": 1,
            "_source": {
              "longField": [
                221,
                309,
                1599208568
              ],
              "keywordField": "hello"
            }
          }
        ]
      }
    }
    ```
    

👉 엘라스틱서치는 색인 과정에서 데이터가 단일 데이터인지 배열 데이터인지에 상관없이 각 값마다 하나의 독립적인 역색인을 구성한다.

### 계층 구조를 지원하는 타입

---

- 필드 하위에 다른 필드가 들어가는 계층 구조의 데이터를 담는 타입으로는 `object`와 `nested`가 있다. 이 둘은 유사하나 배열을 처리할 때의 동작이 다르다.

- object 타입
    - JSON 문서는 필드의 하위에 다른 필드를 여럿 포함하는 객체 데이터를 담을 수 있다.
        
        ```json
        PUT object_test/_doc/1
        {
          "price": 2770.75,
          "spec": {
            "cores": 12,
            "memory": 128,
            "storage": 8000
          }
        }
        ```
        
        ```json
        // request
        GET object_test/_mapping
        
        // response
        {
          "object_test": {
            "mappings": {
              "properties": {
                "price": {
                  "type": "float"
                },
                "spec": {
                  "properties": {
                    "cores": {
                      "type": "long"
                    },
                    "memory": {
                      "type": "long"
                    },
                    "storage": {
                      "type": "long"
                    }
                  }
                }
              }
            }
          }
        }
        ```
        
        - spec 필드의 타입을 명시적으로 `object`라고 표현하지는 않았다.
            
            👉 `object` 타입이 기본값이기 때문이다.
            
            - `properties` 속성 밑에 하위 필드의 매핑 정보가 설정된 것도 확인할 수 있다.
    - 문서는 내부적으로는 평탄화된 키-값 쌍으로 색인된다.
        
        ```json
        {
          "price": 2770.75,
          "spec.cores": 12,
          "spec.memory": 128,
          "spec.storage": 8000
        }
        ```
        
    - `object` 타입이 배열을 처리하는 방법
        
        ```json
        PUT object_test/_doc/2
        {
          "spec": [
            {
              "cores": 12,
              "memory": 128,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 64,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 32,
              "storage": 4000
            }
          ]
        }
        ```
        
        - `bool` 쿼리의 `must` 절에 쿼리를 여러 개 넣으면 각 쿼리가 `AND` 조건으로 연결된다.
            
            ```json
            // request
            GET object_test/_search
            {
              "query": {
                "bool": {
                  "must": [
                    {
                      "term": {
                        "spec.cores": "6"
                      }
                    },
                    {
                      "term": {
                        "spec.memory": "128"
                      }
                    }
                  ]
                }
              }
            }
            
            // response
            {
              "took": 4,
              "timed_out": false,
              "_shards": {
                "total": 1,
                "successful": 1,
                "skipped": 0,
                "failed": 0
              },
              "hits": {
                "total": {
                  "value": 1,
                  "relation": "eq"
                },
                "max_score": 2,
                "hits": [
                  {
                    "_index": "object_test",
                    "_id": "2",
                    "_score": 2,
                    "_source": {
                      "spec": [
                        {
                          "cores": 12,
                          "memory": 128,
                          "storage": 8000
                        },
                        {
                          "cores": 6,
                          "memory": 64,
                          "storage": 8000
                        },
                        {
                          "cores": 6,
                          "memory": 32,
                          "storage": 4000
                        }
                      ]
                    }
                  }
                ]
              }
            }
            ```
            
            - spec.cores가 6이고 spec.memory가 128인 spec 객체는 존재하지 않는데도 검색 결과에 포함됐다.
            - 위 문서는 내부적으로 다음과 같이 평탄화 된다.
                
                ```json
                {
                  "spec.cores": [12, 6, 6]
                  "spec.memory": [128, 64, 32]
                  "spec.storage": [8000, 8000, 4000]
                }
                ```
                
                - spec.cores 역색인에서 6을 찾을 수 있고, spec.memory 역색인에서 128을 찾을 수 있으니 이 문서는 최종 검색 결과에 포함된 것이다.
    - ❗`object` 타입의 배열은 배열을 구성하는 객체 데이터를 서로 독립적인 데이터로 취급하지 않는다.
- nested 타입
    - `object` 타입과는 다르게 배열 내 각 객체를 독립적으로 취급한다.
        
        ```json
        PUT nested_test
        {
          "mappings": {
            "properties": {
              "spec": {
                "type": "nested",
                "properties": {
                  "cores": {
                    "type": "long"
                  },
                  "memory": {
                    "type": "long"
                  },
                  "storage": {
                    "type": "long"
                  }
                }
              }
            }
          }
        }
        
        PUT nested_test/_doc/1
        {
          "spec": [
            {
              "cores": 12,
              "memory": 128,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 64,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 32,
              "storage": 4000
            }
          ]
        }
        ```
        
        ```json
        // request 1: 의도에 따르면, 검색 안되는게 맞다
        GET nested_test/_search
        {
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "spec.cores": "6"
                  }
                },
                {
                  "term": {
                    "spec.memory": "128"
                  }
                }
              ]
            }
          }
        }
        
        // request 2: 의도에 따르면, 검색이 되어야 한다
        GET nested_test/_search
        {
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "spec.cores": "6"
                  }
                },
                {
                  "term": {
                    "spec.memory": "64"
                  }
                }
              ]
            }
          }
        }
        
        // response 1, 2
        {
          "took": 2,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 0,
              "relation": "eq"
            },
            "max_score": null,
            "hits": []
          }
        }
        ```
        
    - `nested` 타입은 객체 배열의 각 객체를 내부적으로 별도의 루씬 문서로 분리해 저장한다.
        - 배열의 원소가 100개라면 부모 문서까지 해서 101개의 문서가 내부적으로 생성된다.
    - `nested` 쿼리라는 전용 쿼리를 이용해서 검색해야 한다.
        
        ```json
        // request
        GET nested_test/_search
        {
          "query": {
            "nested": {
              "path": "spec",
              "query": {
                "bool": {
                  "must": [
                    {
                      "term": {
                        "spec.cores": "6"
                      }
                    },
                    {
                      "term": {
                        "spec.memory": "64"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
        
        // response
        {
          "took": 11,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 2,
            "hits": [
              {
                "_index": "nested_test",
                "_id": "1",
                "_score": 2,
                "_source": {
                  "spec": [
                    {
                      "cores": 12,
                      "memory": 128,
                      "storage": 8000
                    },
                    {
                      "cores": 6,
                      "memory": 64,
                      "storage": 8000
                    },
                    {
                      "cores": 6,
                      "memory": 32,
                      "storage": 4000
                    }
                  ]
                }
              }
            ]
          }
        }
        ```
        
        - `nested` 쿼리를 지정하고 밑에 `path` 부분에 검색 대상이 될 `nested` 타입의 필드 이름을 지정해 줬다. 이후 `nested` 아래의 `query` 절에 기존에 사용하고 싶었던 쿼리를 넣으면 된다.
    - `nested` 타입은 내부적으로 각 객체를 별도의 문서로 분리해서 저장하기 때문에 성능 문제가 있을 수 있다.
        - `index.mapping.nested_fields.limit`: 한 인덱스에 `nested` 타입을 몇 개 까지 지정할 수 있는지를 제한한다. 기본값은 50.
        - `index.mapping.nested_objects.limit`: 한 문서가 `nested` 객체를 몇 개까지 가질 수 있는지를 제한한다. 기본값은 10000
        
        → 이 값들을 무리하게 높이면 OOM의 위험이 있다.
        

- `object` vs `nested` 간단 비교
    
    
    | 타입 | object | nested |
    | --- | --- | --- |
    | 용도 | 일반적인 계층 구조에 사용한다. | 배열 내 각 객체를 독립적으로 취급해야 하는 특수한 상황에서 사용한다. |
    | 성능 | 상대적으로 가볍다. | 상대적으로 무겁다. 내부적으로 숨겨진 문서를 생성한다. |
    | 검색 | 일반적인 쿼리를 사용한다. | 전용 nested 쿼리로 감싸서 사용해야 한다. |

### 그 외 타입

---

| 종류 | 설명 |
| --- | --- |
| geo_point | 위도와 경도를 저장하는 타입 |
| geo_shape | 지도상에 특정 지점이나 선, 도형 등을 표현하는 타입 |
| binary | base64로 인코딩된 문자열을 저장하는 타입 |
| long_range, date_range, ip_range 등 | 경곗값을 지정하는 방법 등을 통해 수, 날짜, IP 등의 범위를 저장하는 타입 |
| completion | 자동완성 검색을 위한 특수한 타입 |

### `text` 타입과 `keyword` 타입

---

- 문자열 자료형을 담는 필드에는 `text` 타입이나 `keyword` 타입 중 하나를 선택해 적용할 수 있다.
- `text`로 지정된 필드 값은 애널라이저가 적용된 후 색인된다.
    - 값을 분석하여 여러 토큰으로 쪼갠 후, 역색인을 구성한다.
    - 텀(`term`): 쪼개진 토큰에 지정한 필터를 적용하는 등의 후처리 작업 후 최종적으로 역색인에 들어가는 형태
- `keyword`로 지정된 필드 값은 쪼개지 않고 역색인을 구성한다.
    - 애널라이저로 분석하는 대신 노멀라이저를 적용한다.
    - 노멀라이저는 간단한 전처리만을 거친 뒤 커다란 단일 텀으로 역색인을 구성한다.

```json
// request
GET mapping_test/_mapping

// response
{
  "mapping_test": {
    "mappings": {
      "properties": {
        "createdDate": {
          "type": "date",
          "format": "strict_date_time || epoch_millis"
        },
        "keywordString": {
          "type": "keyword"
        },
        "longValue": {
          "type": "long"
        },
        "textString": {
          "type": "text"
        }
      }
    }
  }
}
```

- keywordString과 textString 필드 양쪽에 동일한 내용을 담은 문서를 색인
    
    ```json
    PUT mapping_test/_doc/3
    {
      "keywordString": "Hello, World!",
      "textString": "Hello, World!"
    }
    ```
    
    ```json
    // request 1
    GET mapping_test/_search
    {
      "query": {
        "match": {
          "textString": "hello"
        }
      }
    }
    
    // response 1
    {
      "took": 0,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 1,
          "relation": "eq"
        },
        "max_score": 0.2876821,
        "hits": [
          {
            "_index": "mapping_test",
            "_id": "3",
            "_score": 0.2876821,
            "_source": {
              "keywordString": "Hello, World!",
              "textString": "Hello, World!"
            }
          }
        ]
      }
    }
    ```
    
    ```json
    // request 2
    GET mapping_test/_search
    {
      "query": {
        "term": {
          "keywordString": "hello"
        }
      }
    }
    
    // response 2
    {
      "took": 0,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 0,
          "relation": "eq"
        },
        "max_score": null,
        "hits": []
      }
    }
    ```
    

- `text` 타입의 필드: 기본 애널라이저인 `standard` 애널라이저를 거치면 hello 문자열 텀과 world 문자열 텀으로 쪼개진다.
    - 이 두 문자열로 역색인을 구성하기 때문에 hello라는 검색어로 문서를 찾을 수 있는 것이다.
        - Hello라고 입력하면 못찾는다. ([standard analyzer](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html))
            
            ```json
            // request 1: 지정한 애널라이저로 분석
            POST _analyze
            {
              "analyzer": "standard",
              "text": "The 2 QUICK Brown-Foxes jumped over the lazy dog's bone."
            }
            
            // request 2: 특정 인덱스의 애널라이저로 분석
            POST mapping_test/_analyze
            {
              "text": "The 2 QUICK Brown-Foxes jumped over the lazy dog's bone."
            }
            
            // response 1, 2
            [ the, 2, quick, brown, foxes, jumped, over, the, lazy, dog's, bone ]
            ```
            
- `keyword` 타입의 필드: 애널라이저를 통해 문자열을 쪼개지 않는다.
    - 노멀라이저는 전처리 작업 이후 단일 토큰을 생성한다. 명시적으로 특정 노멀라이저를 적용하도록 지정하지 않으면 아무 작업도 수행하지 않고 전체 문자열로 역색인을 생성한다.
    - Hello, World!라고 정확하게 입력해야 찾을 수 있다.
        
        ```json
        // request
        GET mapping_test/_search
        {
          "query": {
            "term": {
              "keywordString": "Hello, World!"
            }
          }
        }
        
        // response
        {
          "took": 1,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 0.2876821,
            "hits": [
              {
                "_index": "mapping_test",
                "_id": "3",
                "_score": 0.2876821,
                "_source": {
                  "keywordString": "Hello, World!",
                  "textString": "Hello, World!"
                }
              }
            ]
          }
        }
        ```
        

- `match` 쿼리: 검색 대상 필드가 `text` 타입인 경우 검색 질의어도 애널라이저로 분석한다.
    
    ```json
    // request: 기본 standard 애널라이저가 질의어를 the, world, said 3개의 텀으로 쪼갠다.
    GET mapping_test/_search
    {
      "query": {
        "match": {
          "textString": "THE WORLD SAID"
        }
      }
    }
    
    // response
    {
      "took": 2,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 1,
          "relation": "eq"
        },
        "max_score": 0.2876821,
        "hits": [
          {
            "_index": "mapping_test",
            "_id": "3",
            "_score": 0.2876821,
            "_source": {
              "keywordString": "Hello, World!",
              "textString": "Hello, World!"
            }
          }
        ]
      }
    }
    ```
    

👉 `text` 타입은 주로 전문 검색에 적합하고 `keyword` 타입은 일치 검색에 적합하다.

- 두 타입은 정렬과 집계, 스크립트 작업을 수행할 때 동작의 차이가 있다.
    
    → `text` 타입보다 `keyword` 타입을 쓰는 편이 낫다.
    
    - `keyword` 타입은 기본적으로 `doc_values`라는 캐시를 사용하고 `text` 타입은 `fielddata`라는 캐시를 사용하기 때문이다.

## 3.2.3 `doc_values`

---

- 엘라스틱서치의 검색은 역색인을 기반으로 한 색인을 이용한다.
    - 텀을 보고 역색인에서 문서를 찾는 방식

- 정렬, 집계, 스크립트 작업 시에는 접근법이 다르다.
    - 문서를 보고 필드 내의 텀을 찾는다.

- `doc_values`: 디스크를 기반(메모리 공간을 차지하지 않음)으로 한 자료 구조. 파일 시스템 캐시를 통해 효율적으로 정렬, 집계, 스크립트 작업을 수행할 수 있게 설계됐다.
    - 문서 인덱싱 때 구축되고, `_source`와 동일한 값을 저장하지만 정렬, 집계에 더 효과적인 column-중심 방식으로 저장한다.
        - `nested` 구조에서의 자식들의 문서가 매우 많을 경우, 이 때는 search를 수행하는 시간이 아닌 자식들의 문서 fetch를 수행하는 시간이 많아지게 된다.(memory, cpu는 놀고 있는데 검색 속도가 느림)
            
            → `doc_values`를 통해 fetch를 수행하면, 빠르게 검색을 수행할 수 있다.
            
    - ex> index 내 필드: a, b
        - Doc 1: a:1, b:4 / Doc 2: a:1, b:5 / Doc 3: a:3, b:6 / Doc 4: b:2
        - inverted `index` for a 필드
            
            
            | a term | document _id |
            | --- | --- |
            | 1 | 1, 2 |
            | 3 | 3 |
        - `doc_values` for a 필드
            
            
            | document _id | a term |
            | --- | --- |
            | 1 | 1 |
            | 2 | 1 |
            | 3 | 3 |
            | 4 | x |
    - `text`와 `annotated_text` 타입을 제외한 거의 모든 필드 타입에서 지원된다.
    
    → 정렬, 집계, 스크립트 작업을 할 일이 없는 필드는 `doc_values`를 끌 수 있다.(디스크 절약) 기본값은 `true`
    
    ```json
    PUT mapping_test/_mapping
    {
      "properties": {
        "notForSort": {
          "type": "keyword",
          "**doc_values**": false // 열기반 저장소를 생성하지 않아 집계, 정렬이 불가능하다.
        }
      }
    }
    ```
    
    - Doc-value-only fields ([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/doc-values.html#doc-value-only-fields))
        - 인덱싱 된 필드보다 쿼리 성능이 훨씬 느리지만 거의 쿼리되지 않을, 쿼리 성능이 중요하지 않은 필드라면 이를 통해 디스크 사용량을 줄일 수 있다. ex> 메트릭 데이터의 게이지 또는 카운터
        - 분석하지 않고 인덱스에도 저장하지 않음. `doc_values`도 끄면 이 필드는 검색할 수 없다. 문서를 찾았을 때 출력용으로만 사용 가능하다.
        
        ```json
        PUT my-index-000001
        {
          "mappings": {
            "properties": {
              "status_code": { 
                "type":  "long" // regular long field
              },
              "session_id": { 
                "type":  "long",
                "doc_values": false, // 안주면 index: false 여도 검색 잘됨
                **"index": false**  // doc-value-only long field
              }
            }
          }
        }
        
        PUT my-index-000001/_doc/1
        {
          "status_code": 1,
          "session_id": 2
        }
        ```
        
        ```json
        GET my-index-000001/_search
        {
          "query": {
            "term": {
              "status_code": 1 // request 1: 검색된다
              "session_id": 2  // request 2: 검색 안된다
            }
          }
        }
        
        // response 1
        {
          "took": 0,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 1,
            "hits": [
              {
                "_index": "my-index-000001",
                "_id": "1",
                "_score": 1,
                "_source": {
                  "status_code": 1,
                  "session_id": 2
                }
              }
            ]
          }
        }
        
        // response 2
        {
          "error": {
            "root_cause": [
              {
                "type": "query_shard_exception",
                "reason": "failed to create query: Cannot search on field [session_id] since it is not indexed nor has doc values.",
                "index_uuid": "ELYaLZTcRBWLtxD8Vn5ofA",
                "index": "my-index-000001"
              }
            ],
            "type": "search_phase_execution_exception",
            "reason": "all shards failed",
            "phase": "query",
            "grouped": true,
            "failed_shards": [
              {
                "shard": 0,
                "index": "my-index-000001",
                "node": "9MrN_Um8QnGFxQWbGD-FtQ",
                "reason": {
                  "type": "query_shard_exception",
                  "reason": "failed to create query: Cannot search on field [session_id] since it is not indexed nor has doc values.",
                  "index_uuid": "ELYaLZTcRBWLtxD8Vn5ofA",
                  "index": "my-index-000001",
                  "caused_by": {
                    "type": "illegal_argument_exception",
                    "reason": "Cannot search on field [session_id] since it is not indexed nor has doc values."
                  }
                }
              }
            ]
          },
          "status": 400
        }
        ```
        
    - `keyword` 필드에는 2가지 데이터 구조가 있다
        - inverted `index`(역색인): 값을 문서 `_id`에 매핑하는 구조 → 검색할 수 있다.
            
            ![Untitled](./image/3/Untitled%201.png)
            
        - `doc_values`: 문서 `_id`를 term에 매핑하는 구조 → 집계, 정렬할 수 있다.
            
            ![Untitled](./image/3/Untitled%202.png)
            

## 3.2.4 `fielddata`

---

- `fielddata`를 사용한 정렬이나 집계 등의 작업 시에는 역색인 전체를 읽어들여 힙 메모리에 올린다.
    - OOM 등 많은 문제를 발생시킬 수 있다. 기본값은 비활성화 상태
        
        ```json
        PUT mapping_test/_mapping
        {
          "properties": {
            "sortableText": {
              "type": "text",
              "fielddata": true // 켜기
            }
          }
        }
        ```
        
    - 메모리에 올리는 역색인 텀은 이미 분석이 완료된 텀

|  | doc_values | fielddata |
| --- | --- | --- |
| 적용 타입 | text와 annotated_text를 제외한 거의 모든 타입 | text, annotated_text |
| 동작 방식 | 디스크 기반이며 파일 시스템 캐시를 활용한다. | 메모리에 역색인 내용 전체를 올린다. OOM에 유의해야 한다. |
| 기본값 | 기본적으로 활성화 | 기본적으로 비활성화 |
- ❗`text` 타입은 정렬, 집계 작업에 적합하지 않다.

## 3.2.5 `_source`

---

- `_source` 필드: 문서 색인 시점에 엘라스틱서치에 전달된 원본 JSON 문서를 저장하는 메타데이터 필드
    - 조회 API나 검색 API가 클라이언트에게 반환할 문서를 확정하고 나면 이 `_source`에 저장된 값을 읽어 클라이언트에게 반환한다.
    - `_source` 필드 자체는 역색인을 생성하지 않기 때문에 검색 대상이 되지 않는다.

### `_source` 비활성화

---

- `_source` 필드는 JSON 문서를 통째로 담기 때문에 디스크를 많이 사용한다.
    - 데이터를 저장하지 않도록 `mappings`에 설정할 수도 있다.
        
        ```json
        PUT no_source_test
        {
          "mappings": {
            "_source": {
              "enabled": false
            }
          }
        }
        ```
        

- `_source`를 비활성화하면 많은 문제가 생길 수 있다.
    - 업데이트와 update_by_query API를 이용할 수 없다.
        - 기존 문서의 내용을 병합한 뒤 새 문서를 색인해야 하는데 기존 문서의 내용을 읽어들일 `_source`가 없기 때문이다.
        - 업데이트 작업: 기존 문서를 삭제하고 업데이트된 새 문서를 색인하는 작업
    - reindex API도 사용할 수 없다.
        - reindex: 원본 인덱스에서 내용을 대상 인덱스에 새로 색인하는 작업
        - `_source`의 원본 JSON 데이터를 읽어 재색인 작업을 수행한다.
    - 엘라스틱서치 메이저 버전을 업그레이드할 때도 문제가 된다.
        - 메이저버전 업그레이드 전에는 reindex를 수행해 예전 버전에서 생성된 인덱스를 재생성해야 한다.

### 인덱스 코덱 변경

---

- 다른 성능을 희생하더라도 디스크 공간을 절약해야만 하는 상황이라면 `_source`의 비활성화보다는 차라리 인덱스 데이터의 압축률을 높이는 편이 낫다.
    
    ```json
    PUT codec_test
    {
      "settings": {
        "index": {
          "codec": "best_compression"
        }
      }
    }
    ```
    
    - 기본값인 `default`는 LZ4 압축을, `best_compression`은 DEFLATE 압축을 사용한다.
        - `best_compression`: 저장된 필드의 성능이 느리지만 압축 비율을 높인다.
    - 이 설정은 동적 변경이 불가능하다.

### `synthetic source`

---

- 엘라스틱서치 8.4 버전부터 도입됐다.
- `synthetic source`를 사용하는 인덱스는 `_source`에 JSON 원문을 저장하지 않는다.
    - 비활성화와 다른점: `_source`를 읽어야 하는 때가 오면 문서 내 각 필드의 `doc_values`를 모아 `_source`를 재조립해 동작한다.
        - fetch 요청(get, search)을 실행할 때 반환될 수 있도록 저장된다.

- 제약
    - ❓인덱스의 모든 필드가 `doc_values`를 사용하는 필드여야 한다.(??)
        - SourceLoader.java, KeywordFieldMapper.java, TextFieldMapper.java
            
            ![Untitled](./image/3/Untitled%203.png)
            
            ![Untitled](./image/3/Untitled%204.png)
            
    - `text` 필드의 경우 `store` 속성([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/mapping-store.html))을 `true`로 주면 해당 기능을 사용할 수 있다.
        - 기본적으로 필드 값은 검색 가능하도록 인덱싱되지만, 저장되지 않는다 → 필드는 쿼리할 수 있지만 원래 필드 값은 검색할 수 없음
        - 보통 `_source` 필드의 일부이기 때문에 문제가 되진 않는다.
        - 특정 상황에서는 필드를 저장하는 것이 합리적일 수 있다.
            
            ```json
            PUT my-index-000001
            {
              "mappings": {
                "properties": {
                  "title": {
                    "type": "text",
                    "store": true 
                  },
                  "date": {
                    "type": "date",
                    "store": true 
                  },
                  "content": {
                    "type": "text"
                  }
                }
              }
            }
            
            PUT my-index-000001/_doc/1
            {
              "title":   "Some short title",
              "date":    "2015-01-01",
              "content": "A very long content field..."
            }
            
            // request: "content"는 넣어도 결과에 안나온다.
            GET my-index-000001/_search
            {
              "stored_fields": [ "title", "date" ] 
            }
            // response
            {
              "took": 8,
              "timed_out": false,
              "_shards": {
                "total": 1,
                "successful": 1,
                "skipped": 0,
                "failed": 0
              },
              "hits": {
                "total": {
                  "value": 1,
                  "relation": "eq"
                },
                "max_score": 1,
                "hits": [
                  {
                    "_index": "my-index-000001",
                    "_id": "1",
                    "_score": 1,
                    "fields": {
                      "date": [
                        "2015-01-01T00:00:00.000Z"
                      ],
                      "title": [
                        "Some short title"
                      ]
                    }
                  }
                ]
              }
            }
            ```
            
    
    → TSDB(`index.mode`가 `time_series`) 인덱스에서만 사용할 수 있다 ([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/mapping-source-field.html))
    
    - 8.4 기준(13개): `boolean`, `byte`, `double`, `float`, `geo_point`, `half_float`, `integer`, `ip`, `keyword`, `long`, `scaled_float`, `short`, `text` (with a `keyword` sub-field)
    - 8.11 기준(21개): `aggregate_metric_double`, `boolean`, `byte`, `date`, `date_nanos`, `dense_vector`, `double`, `flattened`, `float`, `geo_point`, `half_float`, `histogram`, `integer`, `ip`, `keyword`, `long`, `scaled_float`, `short`, `text`, `version`, `wildcard`
    - `_source`를 읽어야 하는 작업의 성능은 떨어진다.
    - 원문 JSON 문자열과는 조금 다를 수 있다.
        - 필드 이름, 배열 내의 값은 오름차순으로 재정렬됨
        - `.` 문자를 포함한 필드 이름은 최대한 object 계층 구조로 조립하려는 등
            
            ```json
            // request
            PUT idx/_doc/1
            {
              "foo.bar.baz": 1
            }
            
            // result
            {
              "foo": {
                "bar": {
                  "baz": 1
                }
              }
            }
            ```
            
        - 배열이 leaf 필드로 이동된다.
            
            ```json
            // request 1
            PUT idx/_doc/1
            {
              "foo": [
                {
                  "bar": 1
                },
                {
                  "bar": 2
                }
              ]
            }
            
            // response 1
            {
              "foo": {
                "bar": [1, 2]
              }
            }
            
            // request 2
            PUT idx/_doc/1
            {
              "foo": [
                {
                  "bar": 1
                },
                {
                  "baz": 2
                }
              ]
            }
            
            // response 2
            {
              "foo": {
                "bar": 1,
                "baz": 2
              }
            }
            ```
            

- 장점
    - 인덱스의 크기를 매우 많이 줄여준다.
        - `_source`를 조회할 필요가 많이 없는 작업을 위주로 수행한다면 디스크 절약과 성능 향상을 기대해볼 수 있다.
    - reindex 작업도 가능하다.

## 3.2.6 `index`

---

- `index` 속성: 해당 필드의 역색인을 만들 것인지를 지정한다. 기본값은 `true`
    - `false`로 설정하면 해당 필드는 역색인이 없기 때문에 일반적인 검색 대상이 되지 않는다.
    - `doc_values`를 사용하는 타입의 필드라면 정렬이나 집계의 대상으로는 사용할 수 있다.
    - 필드가 `doc_values`를 사용할 경우 `index` 속성이 `false`더라도 역색인 대신 `doc_values`를 이용해 검색을 수행한다.
        
        ```json
        PUT mapping_test/_mapping
        {
          "properties": {
            "notSearchableText": {
              "type": "text",
              "index": false
            },
            "docValuesSearchableText": {
              "type": "keyword",
              "index": false
            }
          }
        }
        
        PUT mapping_test/_doc/4
        {
          "textString": "Hello, World!",
          "notSearchableText": "World, Hello!",
          "docValuesSearchableText": "hello"
        }
        ```
        
        ```json
        // request 1: text 필드일 경우 막힌다.
        GET mapping_test/_search
        {
          "query": {
            "match": {
              "notSearchableText": "hello"
            }
          }
        }
        
        // response
        {
          "error": {
            "root_cause": [
              {
                "type": "query_shard_exception",
                "reason": "failed to create query: Cannot search on field [notSearchableText] since it is not indexed.",
                "index_uuid": "NsGLUrXSR7aOrqjzhh-fzQ",
                "index": "mapping_test"
              }
            ],
            "type": "search_phase_execution_exception",
            "reason": "all shards failed",
            "phase": "query",
            "grouped": true,
            "failed_shards": [
              {
                "shard": 0,
                "index": "mapping_test",
                "node": "9MrN_Um8QnGFxQWbGD-FtQ",
                "reason": {
                  "type": "query_shard_exception",
                  "reason": "failed to create query: Cannot search on field [notSearchableText] since it is not indexed.",
                  "index_uuid": "NsGLUrXSR7aOrqjzhh-fzQ",
                  "index": "mapping_test",
                  "caused_by": {
                    "type": "illegal_argument_exception",
                    "reason": "Cannot search on field [notSearchableText] since it is not indexed."
                  }
                }
              }
            ]
          },
          "status": 400
        }
        
        // request 2: keyword 필드일 경우 검색된다.
        GET mapping_test/_search
        {
          "query": {
            "match": {
              "docValuesSearchableText": "hello"
            }
          }
        }
        
        // response 2
        {
          "took": 8,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 1,
            "hits": [
              {
                "_index": "mapping_test",
                "_id": "4",
                "_score": 1,
                "_source": {
                  "textString": "Hello, World!",
                  "notSearchableText": "World, Hello!",
                  "docValuesSearchableText": "hello"
                }
              }
            ]
          }
        }
        ```
        

## 3.2.7 `enabled`

---

- `enabled` 설정은 `object` 타입의 필드에만 적용된다.
- `enabled`가 `false`로 지정된 필드는 엘라스틱서치가 파싱조차 수행하지 않는다.
    - 데이터가 `_source`에는 저장되지만 다른 어느 곳에도 저장되지 않는다.
    - 파싱조차 수행하지 않기 때문에 이후 `object` 타입이 아닌 데이터가 들어와도 타입 충돌이 발생하지 않는다.
    
    ```json
    PUT mapping_test/_mapping
    {
      "properties": {
        "notEnabled": {
          "type": "object",
          "enabled": false
        }
      }
    }
    
    PUT mapping_test/_doc/5
    {
      "notEnabled": {
        "mixedTypeArray": [
          "hello", 4, false, {"foo": "bar"}, null, [2, "E"]
        ]
      }
    }
    
    PUT mapping_test/_doc/6
    {
      "notEnabled": "world"
    }
    ```
    
    - 조회
        
        ```json
        // request
        GET mapping_test/_search
        
        // response
        //...
              {
                "_index": "mapping_test",
                "_id": "5",
                "_score": 1,
                "_source": {
                  "notEnabled": {
                    "mixedTypeArray": [
                      "hello",
                      4,
                      false,
                      {
                        "foo": "bar"
                      },
                      null,
                      [
                        2,
                        "E"
                      ]
                    ]
                  }
                }
              },
              {
                "_index": "mapping_test",
                "_id": "6",
                "_score": 1,
                "_source": {
                  "notEnabled": "world"
                }
              }
            ]
          }
        }
        ```
        
- 서비스 설계상 최종적으로 데이터를 `_source`에서 확인만 하면 되고 그 외 어떠한 활용도 필요치 않은 필드가 있다면 `enabled`를 `false`로 지정하는 것을 고려해볼 수 있다.
