# 3장. 인덱스 설계

# 3.1 인덱스 설정

---

- 인덱스를 생성할 때에는 인덱스의 동작에 관한 설정을 지정할 수 있다.
- 인덱스 설정을 조회하려면 인덱스 이름 뒤에 `/_settings`를 넣어 GET 메서드로 호출한다.
    
    ```powershell
    GET [인덱스 이름]/_settings
    ```
    

- 기존에 존재하지 않는 인덱스에 문서 색인 요청을 하면 엘라스틱서치는 인덱스를 자동으로 생성한다.
    
    ```json
    {
      "my_index": {
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "**number_of_shards**": "1",
            "provided_name": "my_index",
            "creation_date": "1705138019350",
            "**number_of_replicas**": "1",
            "uuid": "6FYtFWOsQxK19uQzq3bO1A",
            "version": {
              "created": "8500003"
            }
          }
        }
      }
    }
    ```
    
    - number_of_shards와 number_of_replicas 값에 주목하자.
    - 이 응답에 명시적으로 포함되지는 않았지만 refresh_interval이라는 중요한 설정이 있다.

## 3.1.1 number_of_shards

---

- number_of_shards: 이 인덱스가 데이터를 몇 개의 샤드로 쪼갤 것인지 지정하는 값
    - 한 번 지정하면 reindex 같은 동작을 통해 인덱스를 통째로 재색인하는 등 특별한 작업을 수행하지 않는 한 바꿀 수 없다.

- 샤드 개수를 어떻게 지정하느냐는 엘라스틱서치 클러스터 전체의 성능에도 큰 영향을 미친다.
    - 샤드 하나마다 루씬 인덱스가 하나씩 더 생성된다.
    - 주 샤드 하나당 복제본 샤드도 늘어난다.

- number_of_shards 설정의 기본값
    - 7 버전부터 1로 변경됐다.
    - 7 버전 미만까지는 5였다.

## 3.1.2 number_of_replicas

---

- number_of_replicas: 주 샤드 하나당 복제본 샤드를 몇 개 둘 것인지를 지정하는 설정
    - 이 값은 인덱스 생성 후에도 동적으로 변경할 수 있다.
        
        ```json
        PUT [인덱스 이름]/_settings
        {
          [변경할 내용]
        }
        ```
        

- ex> number_of_replicas 값을 0으로 동적 업데이트 하는 호출
    
    ```json
    // request
    PUT my_index/_settings
    {
      "index.number_of_replicas": 0
    }
    
    // response
    {
      "acknowledged": true
    }
    ```
    
    - 0으로 지정하면 복제본 샤드를 생성하지 않고 주 샤드만 둔다.
    
    → 복제본 샤드를 생성하지 않는 설정은 주로 대용량의 초기 데이터를 마이그레이션하는 등의 시나리오에서 쓰기 성능을 일시적으로 끌어올리기 위해 사용한다.
    

## 3.1.3 refresh_interval

---

- refresh_interval: 엘라스틱서치가 해당 인덱스를 대상으로 refresh를 얼마나 자주 수행할 것인지를 지정한다.
    - 엘라스틱서치 인덱스에 색인된 문서는 refresh되어야 검색 대상이 되기 때문에 중요한 설정이다.
    
    ```json
    PUT my_index/_settings
    {
      "index.refresh_interval": "1s"
    }
    ```
    
    - 이 값을 -1로 지정하면 주기적 refresh를 수행하지 않는다.

- 이 값을 명시적으로 설정하지 않으면 매 1초마다 refresh를 수행하며, 마지막으로 검색 쿼리가 들어온 시각을 확인한다.
    - 30초 이상 검색 쿼리가 들어오지 않는 것을 확인하면 다음 첫 검색 쿼리가 들어올 때가지 refresh를 수행하지 않는다.
        - 30초 대기 시간은 `index.search.idle.after` 설정에서 변경할 수 있다.
    - 값을 설정하지 않은 상태로 돌리려면 `null`로 업데이트하면 된다.

## 3.1.4 인덱스 설정을 지정하여 인덱스 생성

---

- 인덱스가 없을 때 문서 색인을 요청하여 자동으로 생성된 인덱스
    
    → 주요 인덱스 설정은 모두 기본값이 지정된다. 실제 환경에서는 이러한 방식의 운영은 적절하지 않다.
    

- 수동으로 인덱스를 생성, 기본 설정값으로 인덱스 생성
    
    ```json
    PUT [인덱스 이름]
    ```
    
    ```json
    // request
    PUT my_index2
    
    // response
    {
      "acknowledged": true,
      "shards_acknowledged": true,
      "index": "my_index2"
    }
    ```
    
    - `acknowledged`: 해당 인덱스가 클러스터에 제대로 생성되었는지 여부를 나타낸다.
        - 클러스터 상태 업데이트가 타임아웃이 떨어지기 전에 성공했는지 여부를 의미한다.
    - `shards_acknowledged`: 타임아웃이 떨어지기 전에 지정한 개수만큼 샤드가 활성화됐는지를 나타낸다.
        - 인덱스 생성 시에 `wait_for_active_shards` 인자로 해당 개수를 지정할 수 있다.
            - 기본적으로는 1개의 샤드, 즉 주 샤드가 시간 안에 활성화되면 `true`를 반환한다.
    
    → 타임아웃 전에 해당하는 작업이 완료되었는지를 나타낼 뿐
    

- 인덱스 삭제
    
    ```json
    DELETE [인덱스 이름]
    ```
    
    ```json
    // request
    DELETE my_index2
    
    // response
    {
      "acknowledged": true
    }
    ```
    

- 요청 본문에 설정을 직접 지정하여 인덱스를 생성할 수 있다.
    
    ```json
    PUT [인덱스 이름]
    {
      "settings": {
        [인덱스 설정]
      }
    }
    ```
    
    ```json
    // request
    PUT my_index2
    {
      "settings": {
        "number_of_shards": 2,
        "number_of_replicas": 2
      }
    }
    
    // response
    {
      "acknowledged": true,
      "shards_acknowledged": true,
      "index": "my_index2"
    }
    ```
    
- 설정이 제대로 적용되었는지 확인
    
    ```json
    GET [인덱스 이름]
    ```
    
    ```json
    // request
    GET my_index2
    
    // response
    {
      "my_index2": {
        "aliases": {},
        "mappings": {},
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "**number_of_shards**": "2",
            "provided_name": "my_index2",
            "creation_date": "1705139839056",
            "**number_of_replicas**": "2",
            "uuid": "dWSk3IVWQfKzr8uErjID-A",
            "version": {
              "created": "8500003"
            }
          }
        }
      }
    }
    ```
    
    - settings 항목 밑으로 보이는 인덱스 설정 외에도 `mappings`라는 항목을 확인할 수 있다.
    - 이곳에는 인덱스 설계의 핵심인 매핑과 필드 타입에 관한 정보가 들어간다.

# 3.2 매핑과 필드 타입

---

- 매핑은 문서가 인덱스에 어떻게 색인되고 저장되는지 정의하는 부분이다.
    - JSON 문서의 각 필드를 어떤 방식으로 분석하고 색인할지, 어떤 타입으로 저장할지 등을 세부적으로 지정할 수 있다.

- ex> my_index2 인덱스에 문서를 하나 색인하고 인덱스 정보를 확인해보자.
    
    ```json
    // request
    PUT my_index2/_doc/1
    {
      "title": "hello world",
      "views": 1234,
      "public": true,
      "point": 4.5,
      "created": "2019-01-17T14:05:01.234Z"
    }
    
    // response
    {
      "_index": "my_index2",
      "_id": "1",
      "_version": 1,
      "result": "created",
      "_shards": {
        "total": 3,
        "successful": 1,
        "failed": 0
      },
      "_seq_no": 0,
      "_primary_term": 1
    }
    ```
    
    ```json
    // request
    GET my_index2
    
    // response
    // 동적 매핑
    {
      "my_index2": {
        "aliases": {},
        "mappings": {
          "properties": {
            "created": {
              "type": "date"
            },
            "point": {
              "type": "float"
            },
            "public": {
              "type": "boolean"
            },
            "title": {
              "type": "text",
              "fields": {
                "keyword": {
                  "type": "keyword",
                  "ignore_above": 256
                }
              }
            },
            "views": {
              "type": "long"
            }
          }
        },
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "number_of_shards": "2",
            "provided_name": "my_index2",
            "creation_date": "1705139839056",
            "number_of_replicas": "2",
            "uuid": "dWSk3IVWQfKzr8uErjID-A",
            "version": {
              "created": "8500003"
            }
          }
        }
      }
    }
    ```
    
    - `mappings` 항목 밑에 각 필드의 타입과 관련된 정보가 새로 생긴 것을 확인할 수 있다.

## 3.2.1 동적 매핑 vs 명시적 매핑

---

- 인덱스를 생성할 때 직접 매핑 정보를 명시적으로 지정
    
    ```json
    PUT mapping_test
    {
      "mappings": {
        "properties": {
          "createdDate": {
            "type": "date",
            "format": "strict_date_time || epoch_millis"
          },
          "keywordString": {
            "type": "keyword"
          },
          "textString": {
            "type": "text"
          }
        }
      },
      "settings": {
        "number_of_replicas": 1,
        "number_of_shards": 1
      }
    }
    ```
    
    - 필드 타입을 포함한 매핑 설정 내 대부분의 내용은 한 번 지정되면 사실상 변경이 불가능하다.

- 동적 매핑은 예기치 않은 신규 필드가 포함된 데이터 인입 등의 상황에 있어 유연한 운영을 가능하게 해 준다.
    - 하지만 신규 필드 추가가 예정돼 있다면 동적 매핑에 기대지 말고 명시적으로 매핑을 지정하는 것이 좋다.

- 이미 인덱스가 생성된 경우에도 신규 필드를 추가할 때에는 매핑 정보를 추가할 수 있다.
    
    ```json
    PUT mapping_test/_mapping
    {
      "properties": {
        "longValue": {
          "type": "long"
        }
      }
    }
    ```
    
- 변경된 매핑 정보를 확인
    
    ```json
    // request
    GET mapping_test/_mapping
    
    // response
    {
      "mapping_test": {
        "mappings": {
          "properties": {
            "createdDate": {
              "type": "date",
              "format": "strict_date_time || epoch_millis"
            },
            "keywordString": {
              "type": "keyword"
            },
            "longValue": {
              "type": "long"
            },
            "textString": {
              "type": "text"
            }
          }
        }
      }
    }
    ```
    

## 3.2.2 필드 타입

---

- 필드 타입: 필드의 값이 어떤 형태로 저장될지를 지정한다. 한 번 지정되면 변경이 불가능하므로 매우 신중하게 지정해야 한다.
    
    
    | 분류 | 종류 |
    | --- | --- |
    | 심플 타입 | text, keyword, date, long, double, boolean, ip 등 |
    | 계층 구조를 지원하는 타입 | object, nested 등 |
    | 그 외 특수한 타입 | geo_point, geo_shape 등 |

### 심플 타입

---

- 심플 타입: 직관적으로 알기 쉬운 간단한 자료형

- 숫자타입
    
    
    | 종류 |  |
    | --- | --- |
    | long | 64비트 부호 있는 정수 (-2^63 ~ 2^63-1) |
    | integer | 32비트 부호 있는 정수 |
    | short | 16비트 부호 있는 정수 |
    | byte | 8비트 부호 있는 정수 |
    | double | 64비트 부동소수점 수 |
    | float | 32비트 부동소수점 수 |
    | half_float | 16비트 부동소수점 수 |
    | scaled_float | double 고정 환산 계수로 스케일링하여 long으로 저장되는 부동소수점 수 |
    | unsigned_long | unsigned 64비트 정수 (0 ~ 2^64-1) |
    - 정수형 데이터를 담는 필드라면 비즈니스 요건에 맞는 범위에서 가장 작은 비트를 사용하는 자료형을 고르면 된다.
        - 😃 작은 비트를 사용하는 자료형을 고르면 색인과 검색 시 이득이 있다.
        - 다만 저장할 때는 실제 값에 맞춰 최적화되기 때문에 디스크 사용량에는 이득이 없다.
            
            ![Untitled](./image/3/Untitled.png)
            
            - C언어 기준, `char`형(n1, n2) 덧셈결과로 반환값 크기는 1바이트, short형(n3, n4) 덧셈결과로 반환된 크기는 2바이트가 될 것 같지만 → 출력은 모두 4바이트를 보여준다.
            - ❗일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 `Int`로 정의한다.
                
                → `Int`형 연산 속도가 다른 자료형의 연산 속도에 비해서 동일하거나 더 빠르다.
                
            - 😃 `Int`형 연산이 CPU가 성능을 내기에 가장 좋은 연산이다 보니, 그보다 작은 크기의 데이터는 `Int`형으로 바꿔 연산이 진행된다.
    
    - 부동소수점 수를 담는 필드라면 환산 계수로 스케일링해서 정수로 저장하는 `scaled_float` 타입을 고려할 수 있다.
        - `scaling_factor`라는 환산 계수 인자를 지정해야 한다.
        - ex> `scaling_factor` 값이 100이고 실제 필드의 값이 3.943이라면 엘라스틱서치는 이를 394라는 정수로 색인한다.
            - 이후의 검색, 집계, 정렬 과정에서는 이 필드가 3.94 값을 가진 것처럼 동작한다.
            - 압축이 쉬워 디스크 공간에서 이득을 볼 수 있다.
    
    <aside>
    💡 숫자 identifiers 매핑 ([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html))
    
    - 만약 숫자 식별자를 `range` 쿼리로 검색할 일이 없을것 같다면 `keyword` 타입 사용을 고려해봐라.
        - `term` 쿼리는 종종 `numeric` 필드보다 `keyowrd` 필드를 더 빠르게 검색한다.
    </aside>
    
- date 타입
    - mapping_test 인덱스에 문서 두 개를 추가해 보자.
        
        ```json
        PUT mapping_test/_doc/1
        {
          "createdDate": "2020-09-03T02:41:32.001Z"
        }
        PUT mapping_test/_doc/2
        {
          "createdDate": 1599068514123 // 2020년 9월 3일 목요일 오전 2:41:54.123
        }
        ```
        
        ```json
        // request
        GET mapping_test/_search
        {
          "query": {
            "range": {
              "createdDate": {
                "gte": "2020-09-02T17:00:00.000Z",
                "lte": "2020-09-03T03:00:00.000Z"
              }
            }
          }
        }
        
        // response
        {
          "took": 2,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 2,
              "relation": "eq"
            },
            "max_score": 1,
            "hits": [
              {
                "_index": "mapping_test", // 책에 있는 "_type": "_doc" 없어짐
                "_id": "1",
                "_score": 1,
                "_source": {
                  "createdDate": "2020-09-03T02:41:32.001Z"
                }
              },
              {
                "_index": "mapping_test",
                "_id": "2",
                "_score": 1,
                "_source": {
                  "createdDate": 1599068514123
                }
              }
            ]
          }
        }
        ```
        
    - 엘라스틱서치의 `date` 타입은 인입되는 데이터의 형식을 `format`이라는 옵션으로 지정한다.
        - 문서가 어떤 형식으로 들어오더라도 엘라스틱서치 내부적으로는 UTC 시간대로 변환하는 과정을 거쳐 epoch milliseconds 형식의 long 숫자로 색인된다.
        - `format`에는 `java.time.format.DateTimeFormatter`로 인식 가능한 패턴을 사용할 수 있다.
            - 그 외에 다양한 빌트인 형식이 미리 갖춰져 있다.
            
            | 종류 | 설명 |
            | --- | --- |
            | epoch_millis | 밀리초 단위로 표현한 epoch 시간 |
            | epoch_second | 초 단위로 표현한 epoch 시간 |
            | date_time | yyyyMMdd 형태로 표현한 날짜 |
            | strict_date_time | yyyy-MM-dd’T’HH:mm:ss.SSSZ로 표현한 날짜와 시간 |
            | date_optional_time | 최소 연 단위의 날짜를 포함해야 하며, 선택적으로 시간 정보도 포함하여 ISO datetime 형태로 표현된 날짜와 시간
            ex> yyyy-MM-dd 또는 yyyy-MM-dd’T’HH:mm:ss.SSSZ |
            | strict_date_optional_time | date_optional_time과 동일하지만 연, 월, 일이 각각 4자리, 2자리, 2자리임을 보장해야 한다. |
        - 여러 형식을 허용하도록 지정하려면 `format`을 `||` 문자로 이어 붙이면 된다.
            - 기본값: `strict_date_optional_time || epoch_millis`

### 배열

---

- 엘라스틱서치에는 배열을 표현하는 별도의 타입 구분이 없다.
    - `long` 타입의 필드에는 309라는 단일 숫자 데이터를 넣을 수도 있고 [221, 309, 1599208568] 배열 데이터도 넣을 수 있다.

- ex> array_test 인덱스 생성을 완료한 후 해당 인덱스에 다음의 두 문서를 색인해 보자.
    
    ```json
    PUT array_test
    {
      "mappings": {
        "properties": {
          "longField": {
            "type": "long"
          },
          "keywordField": {
            "type": "keyword"
          }
        }
      }
    }
    ```
    
    ```json
    PUT array_test/_doc/1
    {
      "longField": 309,
      "keywordField": ["hello", "world"]
    }
    PUT array_test/_doc/2
    {
      "longField": [221, 309, 1599208568],
      "keywordField": "hello"
    }
    ```
    
    - 성공적으로 색인될 것이다.
- 그러나 여러 타입이 혼합된 배열 데이터의 색인을 요청하는 경우 색인은 실패한다.
    
    ```json
    // request
    PUT array_test/_doc/3
    {
      "longField": [221, "hello"]
    }
    
    // response
    {
      "error": {
        "root_cause": [
          {
            "type": "document_parsing_exception",
            "reason": "[2:22] failed to parse field [longField] of type [long] in document with id '3'. Preview of field's value: 'hello'"
          }
        ],
        "type": "document_parsing_exception",
        "reason": "[2:22] failed to parse field [longField] of type [long] in document with id '3'. Preview of field's value: 'hello'",
        "caused_by": {
          "type": "illegal_argument_exception",
          "reason": "For input string: \"hello\""
        }
      },
      "status": 400
    }
    ```
    

- `term` 쿼리: 문서 내 지정한 필드의 값이 질의한 값과 일치하는 문서를 검색하는 기본적인 쿼리
    
    ```json
    // request
    GET array_test/_search
    {
      "query": {
        "term": {
          "longField": 309
        }
      }
    }
    
    // response
    {
      "took": 1,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 2,
          "relation": "eq"
        },
        "max_score": 1,
        "hits": [
          {
            "_index": "array_test",
            "_id": "1",
            "_score": 1,
            "_source": {
              "longField": 309,
              "keywordField": [
                "hello",
                "world"
              ]
            }
          },
          {
            "_index": "array_test",
            "_id": "2",
            "_score": 1,
            "_source": {
              "longField": [
                221,
                309,
                1599208568
              ],
              "keywordField": "hello"
            }
          }
        ]
      }
    }
    ```
    

👉 엘라스틱서치는 색인 과정에서 데이터가 단일 데이터인지 배열 데이터인지에 상관없이 각 값마다 하나의 독립적인 역색인을 구성한다.

### 계층 구조를 지원하는 타입

---

- 필드 하위에 다른 필드가 들어가는 계층 구조의 데이터를 담는 타입으로는 `object`와 `nested`가 있다. 이 둘은 유사하나 배열을 처리할 때의 동작이 다르다.

- object 타입
    - JSON 문서는 필드의 하위에 다른 필드를 여럿 포함하는 객체 데이터를 담을 수 있다.
        
        ```json
        PUT object_test/_doc/1
        {
          "price": 2770.75,
          "spec": {
            "cores": 12,
            "memory": 128,
            "storage": 8000
          }
        }
        ```
        
        ```json
        // request
        GET object_test/_mapping
        
        // response
        {
          "object_test": {
            "mappings": {
              "properties": {
                "price": {
                  "type": "float"
                },
                "spec": {
                  "properties": {
                    "cores": {
                      "type": "long"
                    },
                    "memory": {
                      "type": "long"
                    },
                    "storage": {
                      "type": "long"
                    }
                  }
                }
              }
            }
          }
        }
        ```
        
        - spec 필드의 타입을 명시적으로 `object`라고 표현하지는 않았다.
            
            👉 `object` 타입이 기본값이기 때문이다.
            
            - `properties` 속성 밑에 하위 필드의 매핑 정보가 설정된 것도 확인할 수 있다.
    - 문서는 내부적으로는 평탄화된 키-값 쌍으로 색인된다.
        
        ```json
        {
          "price": 2770.75,
          "spec.cores": 12,
          "spec.memory": 128,
          "spec.storage": 8000
        }
        ```
        
    - `object` 타입이 배열을 처리하는 방법
        
        ```json
        PUT object_test/_doc/2
        {
          "spec": [
            {
              "cores": 12,
              "memory": 128,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 64,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 32,
              "storage": 4000
            }
          ]
        }
        ```
        
        - `bool` 쿼리의 `must` 절에 쿼리를 여러 개 넣으면 각 쿼리가 `AND` 조건으로 연결된다.
            
            ```json
            // request
            GET object_test/_search
            {
              "query": {
                "bool": {
                  "must": [
                    {
                      "term": {
                        "spec.cores": "6"
                      }
                    },
                    {
                      "term": {
                        "spec.memory": "128"
                      }
                    }
                  ]
                }
              }
            }
            
            // response
            {
              "took": 4,
              "timed_out": false,
              "_shards": {
                "total": 1,
                "successful": 1,
                "skipped": 0,
                "failed": 0
              },
              "hits": {
                "total": {
                  "value": 1,
                  "relation": "eq"
                },
                "max_score": 2,
                "hits": [
                  {
                    "_index": "object_test",
                    "_id": "2",
                    "_score": 2,
                    "_source": {
                      "spec": [
                        {
                          "cores": 12,
                          "memory": 128,
                          "storage": 8000
                        },
                        {
                          "cores": 6,
                          "memory": 64,
                          "storage": 8000
                        },
                        {
                          "cores": 6,
                          "memory": 32,
                          "storage": 4000
                        }
                      ]
                    }
                  }
                ]
              }
            }
            ```
            
            - spec.cores가 6이고 spec.memory가 128인 spec 객체는 존재하지 않는데도 검색 결과에 포함됐다.
            - 위 문서는 내부적으로 다음과 같이 평탄화 된다.
                
                ```json
                {
                  "spec.cores": [12, 6, 6]
                  "spec.memory": [128, 64, 32]
                  "spec.storage": [8000, 8000, 4000]
                }
                ```
                
                - spec.cores 역색인에서 6을 찾을 수 있고, spec.memory 역색인에서 128을 찾을 수 있으니 이 문서는 최종 검색 결과에 포함된 것이다.
    - ❗`object` 타입의 배열은 배열을 구성하는 객체 데이터를 서로 독립적인 데이터로 취급하지 않는다.
- nested 타입
    - `object` 타입과는 다르게 배열 내 각 객체를 독립적으로 취급한다.
        
        ```json
        PUT nested_test
        {
          "mappings": {
            "properties": {
              "spec": {
                "type": "nested",
                "properties": {
                  "cores": {
                    "type": "long"
                  },
                  "memory": {
                    "type": "long"
                  },
                  "storage": {
                    "type": "long"
                  }
                }
              }
            }
          }
        }
        
        PUT nested_test/_doc/1
        {
          "spec": [
            {
              "cores": 12,
              "memory": 128,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 64,
              "storage": 8000
            },
            {
              "cores": 6,
              "memory": 32,
              "storage": 4000
            }
          ]
        }
        ```
        
        ```json
        // request 1: 의도에 따르면, 검색 안되는게 맞다
        GET nested_test/_search
        {
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "spec.cores": "6"
                  }
                },
                {
                  "term": {
                    "spec.memory": "128"
                  }
                }
              ]
            }
          }
        }
        
        // request 2: 의도에 따르면, 검색이 되어야 한다
        GET nested_test/_search
        {
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "spec.cores": "6"
                  }
                },
                {
                  "term": {
                    "spec.memory": "64"
                  }
                }
              ]
            }
          }
        }
        
        // response 1, 2
        {
          "took": 2,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 0,
              "relation": "eq"
            },
            "max_score": null,
            "hits": []
          }
        }
        ```
        
    - `nested` 타입은 객체 배열의 각 객체를 내부적으로 별도의 루씬 문서로 분리해 저장한다.
        - 배열의 원소가 100개라면 부모 문서까지 해서 101개의 문서가 내부적으로 생성된다.
    - `nested` 쿼리라는 전용 쿼리를 이용해서 검색해야 한다.
        
        ```json
        // request
        GET nested_test/_search
        {
          "query": {
            "nested": {
              "path": "spec",
              "query": {
                "bool": {
                  "must": [
                    {
                      "term": {
                        "spec.cores": "6"
                      }
                    },
                    {
                      "term": {
                        "spec.memory": "64"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
        
        // response
        {
          "took": 11,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 2,
            "hits": [
              {
                "_index": "nested_test",
                "_id": "1",
                "_score": 2,
                "_source": {
                  "spec": [
                    {
                      "cores": 12,
                      "memory": 128,
                      "storage": 8000
                    },
                    {
                      "cores": 6,
                      "memory": 64,
                      "storage": 8000
                    },
                    {
                      "cores": 6,
                      "memory": 32,
                      "storage": 4000
                    }
                  ]
                }
              }
            ]
          }
        }
        ```
        
        - `nested` 쿼리를 지정하고 밑에 `path` 부분에 검색 대상이 될 `nested` 타입의 필드 이름을 지정해 줬다. 이후 `nested` 아래의 `query` 절에 기존에 사용하고 싶었던 쿼리를 넣으면 된다.
    - `nested` 타입은 내부적으로 각 객체를 별도의 문서로 분리해서 저장하기 때문에 성능 문제가 있을 수 있다.
        - `index.mapping.nested_fields.limit`: 한 인덱스에 `nested` 타입을 몇 개 까지 지정할 수 있는지를 제한한다. 기본값은 50.
        - `index.mapping.nested_objects.limit`: 한 문서가 `nested` 객체를 몇 개까지 가질 수 있는지를 제한한다. 기본값은 10000
        
        → 이 값들을 무리하게 높이면 OOM의 위험이 있다.
        

- `object` vs `nested` 간단 비교
    
    
    | 타입 | object | nested |
    | --- | --- | --- |
    | 용도 | 일반적인 계층 구조에 사용한다. | 배열 내 각 객체를 독립적으로 취급해야 하는 특수한 상황에서 사용한다. |
    | 성능 | 상대적으로 가볍다. | 상대적으로 무겁다. 내부적으로 숨겨진 문서를 생성한다. |
    | 검색 | 일반적인 쿼리를 사용한다. | 전용 nested 쿼리로 감싸서 사용해야 한다. |

### 그 외 타입

---

| 종류 | 설명 |
| --- | --- |
| geo_point | 위도와 경도를 저장하는 타입 |
| geo_shape | 지도상에 특정 지점이나 선, 도형 등을 표현하는 타입 |
| binary | base64로 인코딩된 문자열을 저장하는 타입 |
| long_range, date_range, ip_range 등 | 경곗값을 지정하는 방법 등을 통해 수, 날짜, IP 등의 범위를 저장하는 타입 |
| completion | 자동완성 검색을 위한 특수한 타입 |

### `text` 타입과 `keyword` 타입

---

- 문자열 자료형을 담는 필드에는 `text` 타입이나 `keyword` 타입 중 하나를 선택해 적용할 수 있다.
- `text`로 지정된 필드 값은 애널라이저가 적용된 후 색인된다.
    - 값을 분석하여 여러 토큰으로 쪼갠 후, 역색인을 구성한다.
    - 텀(`term`): 쪼개진 토큰에 지정한 필터를 적용하는 등의 후처리 작업 후 최종적으로 역색인에 들어가는 형태
- `keyword`로 지정된 필드 값은 쪼개지 않고 역색인을 구성한다.
    - 애널라이저로 분석하는 대신 노멀라이저를 적용한다.
    - 노멀라이저는 간단한 전처리만을 거친 뒤 커다란 단일 텀으로 역색인을 구성한다.

```json
// request
GET mapping_test/_mapping

// response
{
  "mapping_test": {
    "mappings": {
      "properties": {
        "createdDate": {
          "type": "date",
          "format": "strict_date_time || epoch_millis"
        },
        "keywordString": {
          "type": "keyword"
        },
        "longValue": {
          "type": "long"
        },
        "textString": {
          "type": "text"
        }
      }
    }
  }
}
```

- keywordString과 textString 필드 양쪽에 동일한 내용을 담은 문서를 색인
    
    ```json
    PUT mapping_test/_doc/3
    {
      "keywordString": "Hello, World!",
      "textString": "Hello, World!"
    }
    ```
    
    ```json
    // request 1
    GET mapping_test/_search
    {
      "query": {
        "match": {
          "textString": "hello"
        }
      }
    }
    
    // response 1
    {
      "took": 0,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 1,
          "relation": "eq"
        },
        "max_score": 0.2876821,
        "hits": [
          {
            "_index": "mapping_test",
            "_id": "3",
            "_score": 0.2876821,
            "_source": {
              "keywordString": "Hello, World!",
              "textString": "Hello, World!"
            }
          }
        ]
      }
    }
    ```
    
    ```json
    // request 2
    GET mapping_test/_search
    {
      "query": {
        "term": {
          "keywordString": "hello"
        }
      }
    }
    
    // response 2
    {
      "took": 0,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 0,
          "relation": "eq"
        },
        "max_score": null,
        "hits": []
      }
    }
    ```
    

- `text` 타입의 필드: 기본 애널라이저인 `standard` 애널라이저를 거치면 hello 문자열 텀과 world 문자열 텀으로 쪼개진다.
    - 이 두 문자열로 역색인을 구성하기 때문에 hello라는 검색어로 문서를 찾을 수 있는 것이다.
        - Hello라고 입력하면 못찾는다. ([standard analyzer](https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html))
            
            ```json
            // request 1: 지정한 애널라이저로 분석
            POST _analyze
            {
              "analyzer": "standard",
              "text": "The 2 QUICK Brown-Foxes jumped over the lazy dog's bone."
            }
            
            // request 2: 특정 인덱스의 애널라이저로 분석
            POST mapping_test/_analyze
            {
              "text": "The 2 QUICK Brown-Foxes jumped over the lazy dog's bone."
            }
            
            // response 1, 2
            [ the, 2, quick, brown, foxes, jumped, over, the, lazy, dog's, bone ]
            ```
            
- `keyword` 타입의 필드: 애널라이저를 통해 문자열을 쪼개지 않는다.
    - 노멀라이저는 전처리 작업 이후 단일 토큰을 생성한다. 명시적으로 특정 노멀라이저를 적용하도록 지정하지 않으면 아무 작업도 수행하지 않고 전체 문자열로 역색인을 생성한다.
    - Hello, World!라고 정확하게 입력해야 찾을 수 있다.
        
        ```json
        // request
        GET mapping_test/_search
        {
          "query": {
            "term": {
              "keywordString": "Hello, World!"
            }
          }
        }
        
        // response
        {
          "took": 1,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 0.2876821,
            "hits": [
              {
                "_index": "mapping_test",
                "_id": "3",
                "_score": 0.2876821,
                "_source": {
                  "keywordString": "Hello, World!",
                  "textString": "Hello, World!"
                }
              }
            ]
          }
        }
        ```
        

- `match` 쿼리: 검색 대상 필드가 `text` 타입인 경우 검색 질의어도 애널라이저로 분석한다.
    
    ```json
    // request: 기본 standard 애널라이저가 질의어를 the, world, said 3개의 텀으로 쪼갠다.
    GET mapping_test/_search
    {
      "query": {
        "match": {
          "textString": "THE WORLD SAID"
        }
      }
    }
    
    // response
    {
      "took": 2,
      "timed_out": false,
      "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
      },
      "hits": {
        "total": {
          "value": 1,
          "relation": "eq"
        },
        "max_score": 0.2876821,
        "hits": [
          {
            "_index": "mapping_test",
            "_id": "3",
            "_score": 0.2876821,
            "_source": {
              "keywordString": "Hello, World!",
              "textString": "Hello, World!"
            }
          }
        ]
      }
    }
    ```
    

👉 `text` 타입은 주로 전문 검색에 적합하고 `keyword` 타입은 일치 검색에 적합하다.

- 두 타입은 정렬과 집계, 스크립트 작업을 수행할 때 동작의 차이가 있다.
    
    → `text` 타입보다 `keyword` 타입을 쓰는 편이 낫다.
    
    - `keyword` 타입은 기본적으로 `doc_values`라는 캐시를 사용하고 `text` 타입은 `fielddata`라는 캐시를 사용하기 때문이다.

## 3.2.3 `doc_values`

---

- 엘라스틱서치의 검색은 역색인을 기반으로 한 색인을 이용한다.
    - 텀을 보고 역색인에서 문서를 찾는 방식

- 정렬, 집계, 스크립트 작업 시에는 접근법이 다르다.
    - 문서를 보고 필드 내의 텀을 찾는다.

- `doc_values`: 디스크를 기반(메모리 공간을 차지하지 않음)으로 한 자료 구조. 파일 시스템 캐시를 통해 효율적으로 정렬, 집계, 스크립트 작업을 수행할 수 있게 설계됐다.
    - 문서 인덱싱 때 구축되고, `_source`와 동일한 값을 저장하지만 정렬, 집계에 더 효과적인 column-중심 방식으로 저장한다.
        - `nested` 구조에서의 자식들의 문서가 매우 많을 경우, 이 때는 search를 수행하는 시간이 아닌 자식들의 문서 fetch를 수행하는 시간이 많아지게 된다.(memory, cpu는 놀고 있는데 검색 속도가 느림)
            
            → `doc_values`를 통해 fetch를 수행하면, 빠르게 검색을 수행할 수 있다.
            
    - ex> index 내 필드: a, b
        - Doc 1: a:1, b:4 / Doc 2: a:1, b:5 / Doc 3: a:3, b:6 / Doc 4: b:2
        - inverted `index` for a 필드
            
            
            | a term | document _id |
            | --- | --- |
            | 1 | 1, 2 |
            | 3 | 3 |
        - `doc_values` for a 필드
            
            
            | document _id | a term |
            | --- | --- |
            | 1 | 1 |
            | 2 | 1 |
            | 3 | 3 |
            | 4 | x |
    - `text`와 `annotated_text` 타입을 제외한 거의 모든 필드 타입에서 지원된다.
    
    → 정렬, 집계, 스크립트 작업을 할 일이 없는 필드는 `doc_values`를 끌 수 있다.(디스크 절약) 기본값은 `true`
    
    ```json
    PUT mapping_test/_mapping
    {
      "properties": {
        "notForSort": {
          "type": "keyword",
          "**doc_values**": false // 열기반 저장소를 생성하지 않아 집계, 정렬이 불가능하다.
        }
      }
    }
    ```
    
    - Doc-value-only fields ([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/doc-values.html#doc-value-only-fields))
        - 인덱싱 된 필드보다 쿼리 성능이 훨씬 느리지만 거의 쿼리되지 않을, 쿼리 성능이 중요하지 않은 필드라면 이를 통해 디스크 사용량을 줄일 수 있다. ex> 메트릭 데이터의 게이지 또는 카운터
        - 분석하지 않고 인덱스에도 저장하지 않음. `doc_values`도 끄면 이 필드는 검색할 수 없다. 문서를 찾았을 때 출력용으로만 사용 가능하다.
        
        ```json
        PUT my-index-000001
        {
          "mappings": {
            "properties": {
              "status_code": { 
                "type":  "long" // regular long field
              },
              "session_id": { 
                "type":  "long",
                "doc_values": false, // 안주면 index: false 여도 검색 잘됨
                **"index": false**  // doc-value-only long field
              }
            }
          }
        }
        
        PUT my-index-000001/_doc/1
        {
          "status_code": 1,
          "session_id": 2
        }
        ```
        
        ```json
        GET my-index-000001/_search
        {
          "query": {
            "term": {
              "status_code": 1 // request 1: 검색된다
              "session_id": 2  // request 2: 검색 안된다
            }
          }
        }
        
        // response 1
        {
          "took": 0,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 1,
            "hits": [
              {
                "_index": "my-index-000001",
                "_id": "1",
                "_score": 1,
                "_source": {
                  "status_code": 1,
                  "session_id": 2
                }
              }
            ]
          }
        }
        
        // response 2
        {
          "error": {
            "root_cause": [
              {
                "type": "query_shard_exception",
                "reason": "failed to create query: Cannot search on field [session_id] since it is not indexed nor has doc values.",
                "index_uuid": "ELYaLZTcRBWLtxD8Vn5ofA",
                "index": "my-index-000001"
              }
            ],
            "type": "search_phase_execution_exception",
            "reason": "all shards failed",
            "phase": "query",
            "grouped": true,
            "failed_shards": [
              {
                "shard": 0,
                "index": "my-index-000001",
                "node": "9MrN_Um8QnGFxQWbGD-FtQ",
                "reason": {
                  "type": "query_shard_exception",
                  "reason": "failed to create query: Cannot search on field [session_id] since it is not indexed nor has doc values.",
                  "index_uuid": "ELYaLZTcRBWLtxD8Vn5ofA",
                  "index": "my-index-000001",
                  "caused_by": {
                    "type": "illegal_argument_exception",
                    "reason": "Cannot search on field [session_id] since it is not indexed nor has doc values."
                  }
                }
              }
            ]
          },
          "status": 400
        }
        ```
        
    - `keyword` 필드에는 2가지 데이터 구조가 있다
        - inverted `index`(역색인): 값을 문서 `_id`에 매핑하는 구조 → 검색할 수 있다.
            
            ![Untitled](./image/3/Untitled%201.png)
            
        - `doc_values`: 문서 `_id`를 term에 매핑하는 구조 → 집계, 정렬할 수 있다.
            
            ![Untitled](./image/3/Untitled%202.png)
            

## 3.2.4 `fielddata`

---

- `fielddata`를 사용한 정렬이나 집계 등의 작업 시에는 역색인 전체를 읽어들여 힙 메모리에 올린다.
    - OOM 등 많은 문제를 발생시킬 수 있다. 기본값은 비활성화 상태
        
        ```json
        PUT mapping_test/_mapping
        {
          "properties": {
            "sortableText": {
              "type": "text",
              "fielddata": true // 켜기
            }
          }
        }
        ```
        
    - 메모리에 올리는 역색인 텀은 이미 분석이 완료된 텀

|  | doc_values | fielddata |
| --- | --- | --- |
| 적용 타입 | text와 annotated_text를 제외한 거의 모든 타입 | text, annotated_text |
| 동작 방식 | 디스크 기반이며 파일 시스템 캐시를 활용한다. | 메모리에 역색인 내용 전체를 올린다. OOM에 유의해야 한다. |
| 기본값 | 기본적으로 활성화 | 기본적으로 비활성화 |
- ❗`text` 타입은 정렬, 집계 작업에 적합하지 않다.

## 3.2.5 `_source`

---

- `_source` 필드: 문서 색인 시점에 엘라스틱서치에 전달된 원본 JSON 문서를 저장하는 메타데이터 필드
    - 조회 API나 검색 API가 클라이언트에게 반환할 문서를 확정하고 나면 이 `_source`에 저장된 값을 읽어 클라이언트에게 반환한다.
    - `_source` 필드 자체는 역색인을 생성하지 않기 때문에 검색 대상이 되지 않는다.

### `_source` 비활성화

---

- `_source` 필드는 JSON 문서를 통째로 담기 때문에 디스크를 많이 사용한다.
    - 데이터를 저장하지 않도록 `mappings`에 설정할 수도 있다.
        
        ```json
        PUT no_source_test
        {
          "mappings": {
            "_source": {
              "enabled": false
            }
          }
        }
        ```
        

- `_source`를 비활성화하면 많은 문제가 생길 수 있다.
    - 업데이트와 update_by_query API를 이용할 수 없다.
        - 기존 문서의 내용을 병합한 뒤 새 문서를 색인해야 하는데 기존 문서의 내용을 읽어들일 `_source`가 없기 때문이다.
        - 업데이트 작업: 기존 문서를 삭제하고 업데이트된 새 문서를 색인하는 작업
    - reindex API도 사용할 수 없다.
        - reindex: 원본 인덱스에서 내용을 대상 인덱스에 새로 색인하는 작업
        - `_source`의 원본 JSON 데이터를 읽어 재색인 작업을 수행한다.
    - 엘라스틱서치 메이저 버전을 업그레이드할 때도 문제가 된다.
        - 메이저버전 업그레이드 전에는 reindex를 수행해 예전 버전에서 생성된 인덱스를 재생성해야 한다.

### 인덱스 코덱 변경

---

- 다른 성능을 희생하더라도 디스크 공간을 절약해야만 하는 상황이라면 `_source`의 비활성화보다는 차라리 인덱스 데이터의 압축률을 높이는 편이 낫다.
    
    ```json
    PUT codec_test
    {
      "settings": {
        "index": {
          "codec": "best_compression"
        }
      }
    }
    ```
    
    - 기본값인 `default`는 LZ4 압축을, `best_compression`은 DEFLATE 압축을 사용한다.
        - `best_compression`: 저장된 필드의 성능이 느리지만 압축 비율을 높인다.
    - 이 설정은 동적 변경이 불가능하다.

### `synthetic source`

---

- 엘라스틱서치 8.4 버전부터 도입됐다.
- `synthetic source`를 사용하는 인덱스는 `_source`에 JSON 원문을 저장하지 않는다.
    - 비활성화와 다른점: `_source`를 읽어야 하는 때가 오면 문서 내 각 필드의 `doc_values`를 모아 `_source`를 재조립해 동작한다.
        - fetch 요청(get, search)을 실행할 때 반환될 수 있도록 저장된다.

- 제약
    - ❓인덱스의 모든 필드가 `doc_values`를 사용하는 필드여야 한다.(??)
        - SourceLoader.java, KeywordFieldMapper.java, TextFieldMapper.java
            
            ![Untitled](./image/3/Untitled%203.png)
            
            ![Untitled](./image/3/Untitled%204.png)
            
    - `text` 필드의 경우 `store` 속성([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/mapping-store.html))을 `true`로 주면 해당 기능을 사용할 수 있다.
        - 기본적으로 필드 값은 검색 가능하도록 인덱싱되지만, 저장되지 않는다 → 필드는 쿼리할 수 있지만 원래 필드 값은 검색할 수 없음
        - 보통 `_source` 필드의 일부이기 때문에 문제가 되진 않는다.
        - 특정 상황에서는 필드를 저장하는 것이 합리적일 수 있다.
            
            ```json
            PUT my-index-000001
            {
              "mappings": {
                "properties": {
                  "title": {
                    "type": "text",
                    "store": true 
                  },
                  "date": {
                    "type": "date",
                    "store": true 
                  },
                  "content": {
                    "type": "text"
                  }
                }
              }
            }
            
            PUT my-index-000001/_doc/1
            {
              "title":   "Some short title",
              "date":    "2015-01-01",
              "content": "A very long content field..."
            }
            
            // request: "content"는 넣어도 결과에 안나온다.
            GET my-index-000001/_search
            {
              "stored_fields": [ "title", "date" ] 
            }
            // response
            {
              "took": 8,
              "timed_out": false,
              "_shards": {
                "total": 1,
                "successful": 1,
                "skipped": 0,
                "failed": 0
              },
              "hits": {
                "total": {
                  "value": 1,
                  "relation": "eq"
                },
                "max_score": 1,
                "hits": [
                  {
                    "_index": "my-index-000001",
                    "_id": "1",
                    "_score": 1,
                    "fields": {
                      "date": [
                        "2015-01-01T00:00:00.000Z"
                      ],
                      "title": [
                        "Some short title"
                      ]
                    }
                  }
                ]
              }
            }
            ```
            
    
    → TSDB(`index.mode`가 `time_series`) 인덱스에서만 사용할 수 있다 ([레퍼런스](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/mapping-source-field.html))
    
    - 8.4 기준(13개): `boolean`, `byte`, `double`, `float`, `geo_point`, `half_float`, `integer`, `ip`, `keyword`, `long`, `scaled_float`, `short`, `text` (with a `keyword` sub-field)
    - 8.11 기준(21개): `aggregate_metric_double`, `boolean`, `byte`, `date`, `date_nanos`, `dense_vector`, `double`, `flattened`, `float`, `geo_point`, `half_float`, `histogram`, `integer`, `ip`, `keyword`, `long`, `scaled_float`, `short`, `text`, `version`, `wildcard`
    - `_source`를 읽어야 하는 작업의 성능은 떨어진다.
    - 원문 JSON 문자열과는 조금 다를 수 있다.
        - 필드 이름, 배열 내의 값은 오름차순으로 재정렬됨
        - `.` 문자를 포함한 필드 이름은 최대한 object 계층 구조로 조립하려는 등
            
            ```json
            // request
            PUT idx/_doc/1
            {
              "foo.bar.baz": 1
            }
            
            // result
            {
              "foo": {
                "bar": {
                  "baz": 1
                }
              }
            }
            ```
            
        - 배열이 leaf 필드로 이동된다.
            
            ```json
            // request 1
            PUT idx/_doc/1
            {
              "foo": [
                {
                  "bar": 1
                },
                {
                  "bar": 2
                }
              ]
            }
            
            // response 1
            {
              "foo": {
                "bar": [1, 2]
              }
            }
            
            // request 2
            PUT idx/_doc/1
            {
              "foo": [
                {
                  "bar": 1
                },
                {
                  "baz": 2
                }
              ]
            }
            
            // response 2
            {
              "foo": {
                "bar": 1,
                "baz": 2
              }
            }
            ```
            

- 장점
    - 인덱스의 크기를 매우 많이 줄여준다.
        - `_source`를 조회할 필요가 많이 없는 작업을 위주로 수행한다면 디스크 절약과 성능 향상을 기대해볼 수 있다.
    - reindex 작업도 가능하다.

## 3.2.6 `index`

---

- `index` 속성: 해당 필드의 역색인을 만들 것인지를 지정한다. 기본값은 `true`
    - `false`로 설정하면 해당 필드는 역색인이 없기 때문에 일반적인 검색 대상이 되지 않는다.
    - `doc_values`를 사용하는 타입의 필드라면 정렬이나 집계의 대상으로는 사용할 수 있다.
    - 필드가 `doc_values`를 사용할 경우 `index` 속성이 `false`더라도 역색인 대신 `doc_values`를 이용해 검색을 수행한다.
        
        ```json
        PUT mapping_test/_mapping
        {
          "properties": {
            "notSearchableText": {
              "type": "text",
              "index": false
            },
            "docValuesSearchableText": {
              "type": "keyword",
              "index": false
            }
          }
        }
        
        PUT mapping_test/_doc/4
        {
          "textString": "Hello, World!",
          "notSearchableText": "World, Hello!",
          "docValuesSearchableText": "hello"
        }
        ```
        
        ```json
        // request 1: text 필드일 경우 막힌다.
        GET mapping_test/_search
        {
          "query": {
            "match": {
              "notSearchableText": "hello"
            }
          }
        }
        
        // response
        {
          "error": {
            "root_cause": [
              {
                "type": "query_shard_exception",
                "reason": "failed to create query: Cannot search on field [notSearchableText] since it is not indexed.",
                "index_uuid": "NsGLUrXSR7aOrqjzhh-fzQ",
                "index": "mapping_test"
              }
            ],
            "type": "search_phase_execution_exception",
            "reason": "all shards failed",
            "phase": "query",
            "grouped": true,
            "failed_shards": [
              {
                "shard": 0,
                "index": "mapping_test",
                "node": "9MrN_Um8QnGFxQWbGD-FtQ",
                "reason": {
                  "type": "query_shard_exception",
                  "reason": "failed to create query: Cannot search on field [notSearchableText] since it is not indexed.",
                  "index_uuid": "NsGLUrXSR7aOrqjzhh-fzQ",
                  "index": "mapping_test",
                  "caused_by": {
                    "type": "illegal_argument_exception",
                    "reason": "Cannot search on field [notSearchableText] since it is not indexed."
                  }
                }
              }
            ]
          },
          "status": 400
        }
        
        // request 2: keyword 필드일 경우 검색된다.
        GET mapping_test/_search
        {
          "query": {
            "match": {
              "docValuesSearchableText": "hello"
            }
          }
        }
        
        // response 2
        {
          "took": 8,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 1,
            "hits": [
              {
                "_index": "mapping_test",
                "_id": "4",
                "_score": 1,
                "_source": {
                  "textString": "Hello, World!",
                  "notSearchableText": "World, Hello!",
                  "docValuesSearchableText": "hello"
                }
              }
            ]
          }
        }
        ```
        

## 3.2.7 `enabled`

---

- `enabled` 설정은 `object` 타입의 필드에만 적용된다.
- `enabled`가 `false`로 지정된 필드는 엘라스틱서치가 파싱조차 수행하지 않는다.
    - 데이터가 `_source`에는 저장되지만 다른 어느 곳에도 저장되지 않는다.
    - 파싱조차 수행하지 않기 때문에 이후 `object` 타입이 아닌 데이터가 들어와도 타입 충돌이 발생하지 않는다.
    
    ```json
    PUT mapping_test/_mapping
    {
      "properties": {
        "notEnabled": {
          "type": "object",
          "enabled": false
        }
      }
    }
    
    PUT mapping_test/_doc/5
    {
      "notEnabled": {
        "mixedTypeArray": [
          "hello", 4, false, {"foo": "bar"}, null, [2, "E"]
        ]
      }
    }
    
    PUT mapping_test/_doc/6
    {
      "notEnabled": "world"
    }
    ```
    
    - 조회
        
        ```json
        // request
        GET mapping_test/_search
        
        // response
        //...
              {
                "_index": "mapping_test",
                "_id": "5",
                "_score": 1,
                "_source": {
                  "notEnabled": {
                    "mixedTypeArray": [
                      "hello",
                      4,
                      false,
                      {
                        "foo": "bar"
                      },
                      null,
                      [
                        2,
                        "E"
                      ]
                    ]
                  }
                }
              },
              {
                "_index": "mapping_test",
                "_id": "6",
                "_score": 1,
                "_source": {
                  "notEnabled": "world"
                }
              }
            ]
          }
        }
        ```
        
- 서비스 설계상 최종적으로 데이터를 `_source`에서 확인만 하면 되고 그 외 어떠한 활용도 필요치 않은 필드가 있다면 `enabled`를 `false`로 지정하는 것을 고려해볼 수 있다.

# 3.3 애널라이저와 토크나이저

---

- 애널라이저: 0개 이상의 캐릭터 필터, 1개의 토크나이저, 0개 이상의 토큰 필터로 구성된다.
    - 캐릭터 필터, 토크나이저, 토큰 필터의 3단계 순서로 수행된다.

## 3.3.1 analyze API

---

```json
GET _analyze
POST _analyze
```

- 가장 기본적인 `standard` 애널라이저의 분석 결과
    
    ```json
    // request
    POST _analyze
    {
      "analyzer": "standard",
      "text": "Hello, HELLO, World!"
    }
    
    // response
    {
      "tokens": [
        {
          "token": "hello",
          "start_offset": 0,
          "end_offset": 5,
          "type": "<ALPHANUM>",
          "position": 0
        },
        {
          "token": "hello",
          "start_offset": 7,
          "end_offset": 12,
          "type": "<ALPHANUM>",
          "position": 1
        },
        {
          "token": "world",
          "start_offset": 14,
          "end_offset": 19,
          "type": "<ALPHANUM>",
          "position": 2
        }
      ]
    }
    ```
    

## 3.3.2 캐릭터 필터

---

- 캐릭터 필터는 텍스트를 캐릭터의 스트림으로 받아서 특정한 문자를 추가, 변경, 삭제한다.
- 애널라이저에는 0개 이상의 캐릭터 필터를 지정할 수 있다.
- 엘라스틱서치 내장 빌트인 캐릭터 필터
    - `HTML strip` 캐릭터 필터: `<b>`와 같은 HTML 요소 안쪽의 데이터를 꺼낸다. `&apos;`같은 HTML 엔티티도 디코딩한다.
    - `mapping` 캐릭터 필터: 치환할 대상이 되는 문자와 치환 문자를 맵 형태로 선언한다.
    - `pattern replace` 캐릭터 필터: 정규 표현식을 이용해서 문자를 치환한다.

- HTML strip 캐릭터 필터 테스트
    - `analyzer` 대신에 `char_filter`를 지정하면 된다.
    
    ```json
    // request
    POST _analyze
    {
      "char_filter": ["html_strip"],
      "text": "<p>I&apos;m so <b>happy</b>!</p>"
    }
    
    // response
    {
      "tokens": [
        {
          "token": """
    I'm so happy!
    """,
          "start_offset": 0,
          "end_offset": 32,
          "type": "word",
          "position": 0
        }
      ]
    }
    ```
    

## 3.3.3 토크나이저

---

- 토크나이저: 캐릭터 스트림을 받아서 여러 토큰으로 쪼개어 토큰 스트림을 만든다.
    - 애널라이저에는 한 개의 토크나이저만 지정할 수 있다.

- 내장 토크나이저 중 몇 개 소개

### `standard` 토크나이저

---

- 가장 기본적인 토크나이저
- Unicode Text Segmentation 알고리즘을 사용하여 텍스트를 단어 단위로 나눈다.
    - 대부분의 문장 부호가 사라진다.

- 필드 매핑에 특정 애널라이저를 지정하지 않으면 기본값으로 `standard` 에널라이저가 적용된다.
    - `standard` 애널라이저가 `standard` 토크나이저를 이용한다.

### `keyword` 토크나이저

---

- 들어온 텍스트를 쪼개지 않고 그대로 내보낸다.
- 커다란 단일 토큰을 내보낸다.
    
    ```json
    // request
    POST _analyze
    {
      "tokenizer": "keyword",
      "text": "Hello, HELLO, World!"
    }
    
    // response
    {
      "tokens": [
        {
          "token": "Hello, HELLO, World!",
          "start_offset": 0,
          "end_offset": 20,
          "type": "word",
          "position": 0
        }
      ]
    }
    ```
    

- 여러 캐릭터 필터, 토큰 필터와 함께 조합하면 다양한 커스텀 애널라이저 지정이 가능하다.

### `ngram` 토크나이저

---

- 텍스트를 `min_gram` 값 이상 `max_gram` 값 이하의 단위로 쪼갠다.
- ex> `min_gram`: 2, `max_gram`: 3, hello 텍스트를 토크나이저로 쪼개면
    - 총 5개의 토큰으로 쪼개진다: he, hel, el, ell, ll, llo
- ex2> `min_gram`: 3, `max_gram`: 4, Hello, World!
    
    ```json
    // request
    POST _analyze
    {
      "tokenizer": {
        "type": "ngram",
        "min_gram": 3,
        "max_gram": 4
      },
      "text": "Hello, World!"
    }
    
    // response: 21개
    {
      "tokens": [
        {
          "token": "Hel",
          "start_offset": 0,
          "end_offset": 3,
          "type": "word",
          "position": 0
        },
        {
          "token": "Hell",
          "start_offset": 0,
          "end_offset": 4,
          "type": "word",
          "position": 1
        },
        {
          "token": "ell",
          "start_offset": 1,
          "end_offset": 4,
          "type": "word",
          "position": 2
        },
        {
          "token": "ello",
          "start_offset": 1,
          "end_offset": 5,
          "type": "word",
          "position": 3
        },
        {
          "token": "llo",
          "start_offset": 2,
          "end_offset": 5,
          "type": "word",
          "position": 4
        },
        {
          "token": "llo,",
          "start_offset": 2,
          "end_offset": 6,
          "type": "word",
          "position": 5
        },
        {
          "token": "lo,",
          "start_offset": 3,
          "end_offset": 6,
          "type": "word",
          "position": 6
        },
        {
          "token": "lo, ",
          "start_offset": 3,
          "end_offset": 7,
          "type": "word",
          "position": 7
        },
        {
          "token": "o, ",
          "start_offset": 4,
          "end_offset": 7,
          "type": "word",
          "position": 8
        },
        {
          "token": "o, W",
          "start_offset": 4,
          "end_offset": 8,
          "type": "word",
          "position": 9
        },
        {
          "token": ", W",
          "start_offset": 5,
          "end_offset": 8,
          "type": "word",
          "position": 10
        },
        {
          "token": ", Wo",
          "start_offset": 5,
          "end_offset": 9,
          "type": "word",
          "position": 11
        },
        {
          "token": " Wo",
          "start_offset": 6,
          "end_offset": 9,
          "type": "word",
          "position": 12
        },
        {
          "token": " Wor",
          "start_offset": 6,
          "end_offset": 10,
          "type": "word",
          "position": 13
        },
        {
          "token": "Wor",
          "start_offset": 7,
          "end_offset": 10,
          "type": "word",
          "position": 14
        },
        {
          "token": "Worl",
          "start_offset": 7,
          "end_offset": 11,
          "type": "word",
          "position": 15
        },
        {
          "token": "orl",
          "start_offset": 8,
          "end_offset": 11,
          "type": "word",
          "position": 16
        },
        {
          "token": "orld",
          "start_offset": 8,
          "end_offset": 12,
          "type": "word",
          "position": 17
        },
        {
          "token": "rld",
          "start_offset": 9,
          "end_offset": 12,
          "type": "word",
          "position": 18
        },
        {
          "token": "rld!",
          "start_offset": 9,
          "end_offset": 13,
          "type": "word",
          "position": 19
        },
        {
          "token": "ld!",
          "start_offset": 10,
          "end_offset": 13,
          "type": "word",
          "position": 20
        }
      ]
    }
    ```
    

- `token_chars` 속성: 토큰에 포함시킬 타입의 문자를 지정할 수 있다.
    
    
    | 종류 | 설명 |
    | --- | --- |
    | letter | 언어의 글자로 분류되는 문자 |
    | digit | 숫자로 분류되는 문자 |
    | whitespace | 띄어쓰기나 줄바꿈 문자 등 공백으로 인식되는 문자 |
    | punctuation | !나 “ 등 문장 부호 |
    | symbol | $나 √ 같은 기호 |
    | custom | custom_token_chars 설정을 통해 따로 지정한 커스텀 문자 |
- ex3> ex2와 동일한 텍스트에 ngram 토크나이저(`letter`) 적용
    
    ```json
    // request
    POST _analyze
    {
      "tokenizer": {
        "type": "ngram",
        "min_gram": 3,
        "max_gram": 4,
        "token_chars": ["letter"]
      },
      "text": "Hello, World!"
    }
    
    // response: 10개
    {
      "tokens": [
        {
          "token": "Hel",
          "start_offset": 0,
          "end_offset": 3,
          "type": "word",
          "position": 0
        },
        {
          "token": "Hell",
          "start_offset": 0,
          "end_offset": 4,
          "type": "word",
          "position": 1
        },
        {
          "token": "ell",
          "start_offset": 1,
          "end_offset": 4,
          "type": "word",
          "position": 2
        },
        {
          "token": "ello",
          "start_offset": 1,
          "end_offset": 5,
          "type": "word",
          "position": 3
        },
        {
          "token": "llo",
          "start_offset": 2,
          "end_offset": 5,
          "type": "word",
          "position": 4
        },
        {
          "token": "Wor",
          "start_offset": 7,
          "end_offset": 10,
          "type": "word",
          "position": 5
        },
        {
          "token": "Worl",
          "start_offset": 7,
          "end_offset": 11,
          "type": "word",
          "position": 6
        },
        {
          "token": "orl",
          "start_offset": 8,
          "end_offset": 11,
          "type": "word",
          "position": 7
        },
        {
          "token": "orld",
          "start_offset": 8,
          "end_offset": 12,
          "type": "word",
          "position": 8
        },
        {
          "token": "rld",
          "start_offset": 9,
          "end_offset": 12,
          "type": "word",
          "position": 9
        }
      ]
    }
    ```
    

- 동작 방식
    - `ngram` 토크나이저는 먼저 `token_chars`에 지정되지 않은 문자를 기준으로 텍스트를 단어 단위로 쪼갠다.
    - 그다음에 각 단어를 `min_gram` 값 이상 `max_gram` 값 이하의 문자 길이를 가진 토큰으로 쪼갠다.

- `ngram` 토크나이저는 엘라스틱서치에서 RDB의 '`LIKE *검색어*`'와 유사한 검색을 구현하고 싶을 때, 자동 완성 관련 서비스를 구현하고 싶을 때 등에 주로 활용한다.

- 만약 `min_gram`, `max_gram` 차이가 2 이상으로 벌어진다면 분석 시도가 실패하게 된다.
    - `index`.`max_ngram_diff` 인덱스 설정을 통해 지정할 수 있으며 기본값은 1이다.
        - 인덱스를 생성할 때 지정해야 한다.
        - 인덱스를 생성한 뒤 해당 인덱스를 대상으로 analyze API를 사용해야 한다.

### `edge_ngram` 토크나이저

---

- 텍스트를 `token_chars`에 지정되지 않은 문자를 기준으로 삼아 단어 단위로 쪼갠다.
- 그 다음 각 단어를 `min_gram` 값 이상 `max_gram` 값 이하의 문자 길이를 가진 토큰으로 쪼갠다.
    - 하지만 ngram 토크나이저와는 다르게 생성된 모든 토큰의 시작 글자를 단어의 시작 글자로 고정시켜서 생성한다.
        
        ```json
        // request
        POST _analyze
        {
          "tokenizer": {
            "type": "edge_ngram",
            "min_gram": 3,
            "max_gram": 4,
            "token_chars": ["letter"]
          },
          "text": "Hello, World!"
        }
        
        // response
        {
          "tokens": [
            {
              "token": "Hel",
              "start_offset": 0,
              "end_offset": 3,
              "type": "word",
              "position": 0
            },
            {
              "token": "Hell",
              "start_offset": 0,
              "end_offset": 4,
              "type": "word",
              "position": 1
            },
            {
              "token": "Wor",
              "start_offset": 7,
              "end_offset": 10,
              "type": "word",
              "position": 2
            },
            {
              "token": "Worl",
              "start_offset": 7,
              "end_offset": 11,
              "type": "word",
              "position": 3
            }
          ]
        }
        ```
        

### 그 외 토크나이저

---

- `letter` 토크나이저: 공백, 특수문자 등 언어의 글자로 분류되는 문자가 아닌 문자를 만났을 때 쪼갠다.
- `whitespace` 토크나이저: 공백 문자를 만났을 때 쪼갠다.
- `pattern` 토크나이저: 지정한 정규표현식을 단어의 구분자로 사용하여 쪼갠다.

## 3.3.4 토큰 필터

---

- 토큰 필터: 토큰 스트림을 받아서 토큰을 추가, 변경, 삭제한다.
    - 하나의 애널라이저에 토큰 필터를 0개 이상 지정할 수 있다.

- 내장 토큰 필터 중 일부 소개

- `lowercase` / `uppercase` 토큰 필터: 토큰의 내용을 소문자/대문자로 만들어 준다.
- `stop` 토큰 필터: 불용어를 지정하여 제거할 수 있다.
- `synonym` 토큰 필터: 유의어 사전 파일을 지정하여 지정된 유의어를 치환한다.
- `pattern_replace` 토큰 필터: 정규식을 사용하여 토큰의 내용을 치환한다.
- `stemmer` 토큰 필터: 지원되는 몇몇 언어의 어간 추출을 수행한다. 한국어는 지원하지 않는다.
- `trim` 토큰 필터: 토큰의 전후에 위치한 공백 문자를 제거한다.
- `truncate` 토큰 필터: 지정한 길이로 토큰을 자른다.

- token_filter가 아니라 `filter`라는 이름을 사용한다.
    
    ```json
    // request
    POST _analyze
    {
      "filter": ["lowercase"],
      "text": "Hello, World!"
    }
    
    // response
    {
      "tokens": [
        {
          "token": "hello, world!",
          "start_offset": 0,
          "end_offset": 13,
          "type": "word",
          "position": 0
        }
      ]
    }
    ```
    

## 3.3.5 내장 애널라이저

---

- 내장 애널라이저 중 몇 가지
    - `standard` 애널라이저: `standard` 토크나이저와 `lowercase` 토큰 필터로 구성된다.
    - `simple` 애널라이저: `letter`가 아닌 문자 단위로 토큰을 쪼갠 뒤 `lowercase` 토큰 필터를 적용한다.
    - `whitespace` 애널라이저: `whitespace` 토크나이저로 구성된다. 즉 공백 문자 단위로 토큰을 쪼갠다.
    - `stop` 애널라이저: `standard` 애널라이저와 같은 내용이지만 뒤에 `stop` 토큰 필터를 적용해서 불용어를 제거한다.
    - `keyword` 애널라이저: `keyword` 토크나이저로 구성된다. 특별히 분석을 실시하지 않고 하나의 큰 토큰을 그대로 반환한다.
    - `pattern` 애널라이저: `pattern` 토크나이저와 `lowercase` 토큰 필터로 구성된다.
    - `language` 애널라이저: 여러 언어의 분석을 지원한다. 한국어 분석은 지원하지 않는다.
    - `fingerprint` 애널라이저: 중복 검출에 사용할 수 있는 특별한 핑거프린트용 토큰을 생성한다. `standard` 토크나이저 적용 뒤 `lowercase` 토큰 필터, `ASCII folding` 토큰 필터, `stop` 토큰 필터(기본적으로 비활성화), `fingerprint` 토큰 필터를 차례대로 적용한다.
        
        ```json
        // request
        POST _analyze
        {
          "analyzer": "fingerprint",
          "text": "Yes yes, Gödel said this sentence is consistent and."
        }
        
        // response
        {
          "tokens": [
            {
              "token": "and consistent godel is said sentence this yes",
              "start_offset": 0,
              "end_offset": 52,
              "type": "fingerprint",
              "position": 0
            }
          ]
        }
        ```
        

## 3.3.6 애널라이저를 매핑에 적용

---

- 새 인덱스를 생성해보자.
    
    ```json
    PUT analyzer_test
    {
      "settings": {
        "analysis": {
          "analyzer": {
            "default": {
              "type": "keyword"
            }
          }
        }
      },
      "mappings": {
        "properties": {
          "defaultText": {
            "type": "text"
          },
          "standardText": {
            "type": "text",
            "analyzer": "standard"
          }
        }
      }
    }
    ```
    
    - `default`라는 이름으로 애널라이저를 지정하면 기본 애널라이저를 변경할 수 있다.

## 3.3.7 커스텀 애널라이저

---

- 인덱스를 생성하며 커스텀 애널라이저를 지정해 보자.
    
    ```json
    PUT analyzer_test2
    {
      "settings": {
        "analysis": {
          "char_filter": {
            "my_char_filter": {
              "type": "mapping",
              "mappings": [
                "i. => 1.",
                "ii. => 2.",
                "iii. => 3.",
                "iv. => 4."
              ]
            }
          },
          "analyzer": {
            "my_analyzer": {
              "char_filter": [
                "my_char_filter"
              ],
              "tokenizer": "whitespace",
              "filter": [
                "lowercase"
              ]
            }
          }
        }
      },
      "mappings": {
        "properties": {
          "myText": {
            "type": "text",
            "analyzer": "my_analyzer"
          }
        }
      }
    }
    ```
    

- 인덱스의 이름을 지정해서 analyze API 사용
    
    ```json
    GET [인덱스 이름]/_analyze
    POST [인덱스 이름]/_analyze
    ```
    
    ```json
    // request
    GET analyzer_test2/_analyze
    {
      "analyzer": "my_analyzer",
      "text": "i.Hello ii.World iii.Bye, iv.World!"
    }
    
    // response
    {
      "tokens": [
        {
          "token": "1.hello",
          "start_offset": 0,
          "end_offset": 7,
          "type": "word",
          "position": 0
        },
        {
          "token": "2.world",
          "start_offset": 8,
          "end_offset": 16,
          "type": "word",
          "position": 1
        },
        {
          "token": "3.bye,",
          "start_offset": 17,
          "end_offset": 25,
          "type": "word",
          "position": 2
        },
        {
          "token": "4.world!",
          "start_offset": 26,
          "end_offset": 35,
          "type": "word",
          "position": 3
        }
      ]
    }
    ```
    

## 3.3.8 플러그인 설치를 통한 애널라이저 추가와 한국어 형태소 분석

---

- 한국어 형태소 분석을 지원하는 기본 내장 애널라이저는 없다.
- 엘라스틱서치가 공식 제공하는 nori 플러그인을 설치하면 한국어를 분석할 수 있다.
    - 일본어: kuromoji
    - 중국어: smartcn

- 엘라스틱서치의 플러그인 설치
    
    ```powershell
    $ bin/elasticsearch-plugin install [플러그인 이름]
    ```
    
    ```powershell
    jenny@M-N-KIMYOONHEE elasticsearch % bin/elasticsearch-plugin install analysis-nori
    warning: ignoring JAVA_HOME=/opt/homebrew/opt/sdkman-cli/libexec/candidates/java/current; using bundled JDK
    -> Installing analysis-nori
    -> Downloading analysis-nori from elastic
    [=================================================] 100%
    -> Installed analysis-nori
    -> Please restart Elasticsearch to activate any plugins installed
    jenny@M-N-KIMYOONHEE elasticsearch %
    ```
    
    - 플러그인을 설치할 때는 클러스터를 구성하고 있는 모든 노드에 설치해야 한다.
    - 설치를 완료하고 엘라스틱서치 클러스터를 재기동해야 새로 설치한 플러그인이 적용된다.

- nori 애널라이저 테스트
    
    ```json
    // request
    POST _analyze
    {
      "analyzer": "nori",
      "text": "우리는 컴퓨터를 다룬다."
    }
    
    // response
    {
      "tokens": [
        {
          "token": "우리",
          "start_offset": 0,
          "end_offset": 2,
          "type": "word",
          "position": 0
        },
        {
          "token": "컴퓨터",
          "start_offset": 4,
          "end_offset": 7,
          "type": "word",
          "position": 2
        },
        {
          "token": "다루",
          "start_offset": 9,
          "end_offset": 12,
          "type": "word",
          "position": 4
        }
      ]
    }
    ```
    
    - 조사를 제거했고 "다룬다"의 어간인 "다루"를 제대로 분리했다.
        - 한국어 형태소를 잘 분석한 것

## 3.3.9 노멀라이저

---

- 노말라이저: 애널라이저와 비슷한 역할을 하나 적용 대상이 `text` 타입이 아닌 `keyword` 타입의 필드
    - 애널라이저와는 다르게 단일 토큰을 생성한다.
    - 토크나이저 없이 캐릭터 필터, 토큰 필터로 구성된다.
    - 앞에서 살펴봤던 캐릭터 필터와 토큰 필터를 모두 조합할 수 있는 것은 아니다.
        - 최종적으로 단일 토큰을 생성해야 하기 때문에 `ASCII folding`, `lowercase`, `uppercase` 등 글자 단위로 작업을 수행하는 필터만 사용할 수 있다.

- 엘라스틱서치가 제공하는 빌트인 노멀라이저는 `lowercase`밖에 없다.
- 다른 방법으로 `keyword` 타입의 필드를 처리하려면 커스텀 노멀라이저를 조합해 사용해야 한다.
    
    ```json
    PUT normalizer_test
    {
      "settings": {
        "analysis": {
          "normalizer": {
            "my_normalizer": {
              "type": "custom",
              "char_filter": [],
              "filter": [
                "asciifolding", "uppercase"
              ]
            }
          }
        }
      },
      "mappings": {
        "properties": {
          "myNormalizerKeyword": {
            "type": "keyword",
            "normalizer": "my_normalizer"
          },
          "lowercaseKeyword": {
            "type": "keyword",
            "normalizer": "lowercase"
          },
          "defaultKeyword": {
            "type": "keyword"
          }
        }
      }
    }
    ```
    
    - myNormalizerKeyword
        
        ```json
        // request
        GET normalizer_test/_analyze
        {
          "field": "myNormalizerKeyword",
          "text": "Happy World!!"
        }
        
        // response
        {
          "tokens": [
            {
              "token": "HAPPY WORLD!!",
              "start_offset": 0,
              "end_offset": 13,
              "type": "word",
              "position": 0
            }
          ]
        }
        ```
        
    - lowercaseKeyword
        
        ```json
        // request
        GET normalizer_test/_analyze
        {
          "field": "lowercaseKeyword",
          "text": "Happy World!!"
        }
        
        // response
        {
          "tokens": [
            {
              "token": "happy world!!",
              "start_offset": 0,
              "end_offset": 13,
              "type": "word",
              "position": 0
            }
          ]
        }
        ```
        
    - defaultKeyword
        
        ```json
        // request
        GET normalizer_test/_analyze
        {
          "field": "defaultKeyword",
          "text": "Happy World!!"
        }
        
        // response
        {
          "tokens": [
            {
              "token": "Happy World!!",
              "start_offset": 0,
              "end_offset": 13,
              "type": "word",
              "position": 0
            }
          ]
        }
        ```
        

- 특별히 설정하지 않으면 `standard` 애널라이저를 기본 적용하는 `text` 타입과는 달리 `keyword` 타입에는 특별히 설정하지 않으면 아무런 노멀라이저도 적용하지 않는다.

# 3.4 템플릿

---

- 엘라스틱서치를 실무에서 운영하다 보면 수시로 많은 양의 유사한 구조를 가진 인덱스를 생성해야 할 때가 많다.
    - 템플릿: 인덱스 생성 시 사전 정의한 설정대로 인덱스가 생성된다. → 사람의 실수를 줄여 준다.

## 3.4.1 인덱스 템플릿

---

- `index_patterns`: 인덱스 패턴을 지정한다.
- `priority`: 여러 인덱스 템플릿 간 우선 적용순위를 조정할 수 있다. 높을수록 우선순위가 높다.

- 인덱스 템플릿 생성
    
    ```json
    PUT _index_template/my_template
    {
      "index_patterns": [
        "pattern_test_index-*",
        "another_pattern-*"
      ],
      "priority": 1,
      "template": {
        "settings": {
          "number_of_shards": 2,
          "number_of_replicas": 2
        },
        "mappings": {
          "properties": {
            "myTextField": {
              "type": "text"
            }
          }
        }
      }
    }
    ```
    
- 지정한 인덱스 패턴에 맞는 인덱스 생성
    
    ```json
    // request
    PUT pattern_test_index-1
    
    // response
    {
      "acknowledged": true,
      "shards_acknowledged": true,
      "index": "pattern_test_index-1"
    }
    ```
    
    ```json
    // request
    GET pattern_test_index-1
    
    // response
    {
      "pattern_test_index-1": {
        "aliases": {},
        "mappings": {
          "properties": {
            "myTextField": {
              "type": "text"
            }
          }
        },
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "number_of_shards": "2",
            "provided_name": "pattern_test_index-1",
            "creation_date": "1705677148499",
            "number_of_replicas": "2",
            "uuid": "2gHaqANGQh2Yv6HC8VXY8w",
            "version": {
              "created": "8040299"
            }
          }
        }
      }
    }
    ```
    

- 인덱스 템플릿에 적용되는 조건들
    - 명시적 설정도 있고 인덱스 템플릿도 일치하는 경우
        
        → 인덱스 생성 요청의 설정이 인덱스 템플릿, 해당 컴포넌트 템플릿 설정보다 우선한다.
        
    - 인덱스 템플릿 설정은 해당 컴포넌트 템플릿 설정보다 우선한다.

## 3.4.2 컴포넌트 템플릿

---

- 컴포넌트 템플릿: 인덱스 템플릿을 많이 만들어 사용하다 보면 템플릿 간 중복되는 부분이 생긴다. 이런 중복된 부분(`mappings`, `settings`, `aliases`)을 재사용할 수 있는 작은 템플릿 블록으로 쪼갠 것
    - 다양한 인덱스 템플릿을 관리할 때 효율적
    
    ```json
    PUT _component_template/timestamp_mappings
    {
      "template": {
        "mappings": {
          "properties": {
            "timestamp": {
              "type": "date"
            }
          }
        }
      }
    }
    
    PUT _component_template/my_shard_settings
    {
      "template": {
        "settings": {
          "number_of_shards": 2,
          "number_of_replicas": 2
        }
      }
    }
    ```
    
    ```json
    PUT _index_template/my_template2
    {
      "index_patterns": ["timestamp_index-*"],
      "composed_of": ["timestamp_mappings", "my_shard_settings"]
    }
    ```
    
- 인덱스 템플릿을 생성할 때 재사용할 컴포넌트 템플릿 블록을 `composed_of` 항목에 넣으면 된다.
    
    ```json
    // request
    PUT timestamp_index-001
    GET timestamp_index-001
    
    // response
    {
      "timestamp_index-001": {
        "aliases": {},
        "mappings": {
          "properties": {
            "timestamp": {
              "type": "date"
            }
          }
        },
        "settings": {
          "index": {
            "routing": {
              "allocation": {
                "include": {
                  "_tier_preference": "data_content"
                }
              }
            },
            "number_of_shards": "2",
            "provided_name": "timestamp_index-001",
            "creation_date": "1705679281280",
            "number_of_replicas": "2",
            "uuid": "6mb1zUzpQ2-sZTDKDwGkYg",
            "version": {
              "created": "8040299"
            }
          }
        }
      }
    }
    ```
    

## 3.4.3 레거시 템플릿

---

- 인덱스 템플릿과 컴포넌트 템플릿 API는 엘라스틱서치 7.8.0 버전부터 추가된 기능이다.
- 레거시 템플릿: 이전 버전의 템플릿 API
    - `_template`을 사용하며, 컴포넌트 템플릿을 조합할 수 없다.
    - 적용 우선순위가 낮다. 매칭되는 인덱스 템플릿(Composable templates)이 없을 때에만 레거시 템플릿을 확인한다.

## 3.4.4 동적 템플릿

---

- 인덱스에 새로 들어온 필드의 매핑을 사전에 정의한대로 동적 생성하는 기능
- 인덱스 템플릿과는 다르게 매핑 안에 정의한다.
    
    → 인덱스를 생성할 때나 인덱스 템플릿을 생성할 때 함께 지정한다.
    
    ```json
    PUT _index_template/dynamic_mapping_template
    {
      "index_patterns": ["dynamic_mapping*"],
      "priority": 1,
      "template": {
        "settings": {
          "number_of_shards": 2,
          "number_of_replicas": 2
        },
        "mappings": {
          "dynamic_templates": [
            {
              "my_text": {
                "match_mapping_type": "string",
                "match": "*_text",
                "mapping": {
                  "type": "text"
                }
              }
            },
            {
              "my_keyword": {
                "match_mapping_type": "string",
                "match": "*_keyword",
                "mapping": {
                  "type": "keyword"
                }
              }
            }
          ]
        }
      }
    }
    ```
    
- `match_mapping_type`: 새로 들어오는 데이터의 타입을 JSON 파서를 이용해 확인한다.
    - `long`과 `integer`의 차이 등은 인지할 수 없기 때문에 더 큰 범위의 데이터타입 이름을 사용한다.
    - `match_mapping_type`으로 지정할 수 있는 값: `boolean`, `double`, `long`, `string`, `object`, `date`
- `match`/`unmatch`: `match`는 필드의 이름이 지정된 패턴과 일치하는지 확인한다. `unmatch`는 필드 이름이 지정된 패턴과 일치하지 않을 때 적용된다.
    - `match_pattern` 옵션을 regex로 지정하면 단순한 와일드카드 매치를 수행하는 것이 아니라 정규표현식을 이용한 매치를 수행한다.
- `path_match`/`path_unmatch`: `match`/`unmatch`와 동일하게 동작하지만 필드 이름으로 마침표를 사용한 전체 경로를 이용한다.
    - ex> my_object.name.text*

## 3.4.5 빌트인 인덱스 템플릿

---

- 엘라스틱서치 7.9.0 이상 버전은 미리 정의된 빌트인 인덱스 템플릿을 제공한다.
    - 로그나 메트릭을 편리하게 수집하기 위한 X-Pack 전용 추가 기능 Elastic Agent에서 사용하기 위해 내장된 템플릿
    - 다음 인덱스 패턴에 priority 값 100을 가진 템플릿이 사전 정의돼 있다.
        - `metrics-*-*`, `logs-*-*`, `synthetics-*-*`, `profiling-*`

# 3.5 라우팅

---

- 라우팅: 엘라스틱서치가 인덱스를 구성하는 샤드 중 몇 번 샤드를 대상으로 작업을 수행할지 지정하기 위해 사용하는 값
    - 라우팅 값은 문서를 색인할 때 문서마다 하나씩 지정할 수 있다.
- 작업 대상 샤드 번호: 지정된 라우팅 값을 해시한 후 주 샤드의 개수로 나머지 연산을 수행한 값
    - 라우팅 값을 지정하지 않고 문서를 색인하는 경우 라우팅 기본값은 `_id` 값
    
    ```json
    routing_factor = num_routing_shards / num_primary_shards
    shard_num = (hash(_routing) % num_routing_shards) / routing_factor
    ```
    
- 색인 시 라우팅 값을 지정했다면 조회, 업데이트, 삭제, 검색 등의 작업에서도 똑같이 라우팅 지정해야 한다.
    
    ```json
    // request
    PUT routing_test
    {
      "settings": {
        "number_of_shards": 5,
        "number_of_replicas": 1
      }
    }
    
    // response
    {
      "acknowledged": true,
      "shards_acknowledged": true,
      "index": "routing_test"
    }
    
    // request
    PUT routing_test/_doc/1?routing=myid
    {
      "login_id": "myid",
      "comment": "hello world",
      "created_at": "2020-09-08T22:14:09.123Z"
    }
    
    // response
    {
      "_index": "routing_test",
      "_id": "1",
      "_version": 1,
      "result": "created",
      "_shards": {
        "total": 2,
        "successful": 1,
        "failed": 0
      },
      "_seq_no": 0,
      "_primary_term": 1
    }
    ```
    
- 검색할 때
    - 라우팅 값을 기입하지 않으면 전체 샤드를 대상으로 검색
        - 요청 본문을 채우지 않고 `_search` API를 호출하면 특별한 조건으로 제한하지 않고 문서 전체를 검색한다.
            
            ```json
            // request
            GET routing_test/_search
            
            // response: 샤드 전체를 대상으로 검색, hit된 문서의 _routing 메타 필드 안에 색인 시 지정한 라우팅 값 들어가 있음
            {
              "took": 521,
              "timed_out": false,
              "_shards": {
                "total": 5,
                "successful": 5,
                "skipped": 0,
                "failed": 0
              },
              "hits": {
                "total": {
                  "value": 1,
                  "relation": "eq"
                },
                "max_score": 1,
                "hits": [
                  {
                    "_index": "routing_test",
                    "_id": "1",
                    "_score": 1,
                    "_routing": "myid",
                    "_source": {
                      "login_id": "myid",
                      "comment": "hello world",
                      "created_at": "2020-09-08T22:14:09.123Z"
                    }
                  }
                ]
              }
            }
            ```
            
    - 라우팅 값을 명시하면 단일 샤드를 대상으로 검색
        
        ```json
        // request
        GET routing_test/_search?routing=myid
        
        // response: 라우팅 값을 이용하여 샤드 숫자를 정확히 특정한 뒤 그 단일 샤드를 대상으로 검색
        {
          "took": 2,
          "timed_out": false,
          "_shards": {
            "total": 1,
            "successful": 1,
            "skipped": 0,
            "failed": 0
          },
          "hits": {
            "total": {
              "value": 1,
              "relation": "eq"
            },
            "max_score": 1,
            "hits": [
              {
                "_index": "routing_test",
                "_id": "1",
                "_score": 1,
                "_routing": "myid",
                "_source": {
                  "login_id": "myid",
                  "comment": "hello world",
                  "created_at": "2020-09-08T22:14:09.123Z"
                }
              }
            ]
          }
        }
        ```
        

<aside>
💡 운영 환경에서 문서를 색인하거나 검색할 때는 가능한 한 라우팅 값을 지정해 주는 것이 좋다.

- 많은 데이터가 저장된 실제 운영 환경에서 검색을 수행한다면 라우팅 값을 지정했을 때와 그렇지 않을 때의 성능 차이는 매우 크다.
</aside>

## 3.5.1 인덱스 내에서의 _id 고유성 보장

---

- 라우팅 값을 명시하지 않고 검색하면 전체 샤드를 대상으로 검색을 요청함
    - 성능이 떨어지고 검색 결과도 달라질 수 있지만 검색 결과를 받아볼 수는 있다.
- 문서 조회 API 샤드 하나를 지정하여 조회를 수행, 라우팅 값이 올바르게 명시되지 않는다면 다른 샤드에서 문서를 조회한 뒤 요청한 문서가 없다는 응답을 반환할 수 있다.
- 인덱스 내에서 `_id` 값의 고유성 검증은 샤드 단위로 보장된다.
    - 색인, 조회, 업데이트, 삭제 작업이 모두 라우팅 수행 이후의 단일 샤드 내에서 이뤄지기 때문이다.
    - 라우팅 값이 다르게 지정되면 한 인덱스 내에서 같은 `_id`를 가진 문서가 여러 개 생길 수도 있다.

## 3.5.2 인덱스 매핑에서 라우팅을 필수로 지정하기

---

- 인덱스 매핑에서 `_routing` 메타 필드를 지정하여 라우팅 값 명시를 필수로 설정할 수 있다.
    
    ![Untitled](./image/3/Untitled%205.png)
    
    - 라우팅 `required` 값을 `true`로 지정하면 라우팅 값이 명시되지 않은 색인, 조회, 업데이트, 삭제 요청은 실패하게 된다.

# 참고

---

## 인덱스 리스트 보기

---

```json
GET _cat/indices?v
```

![Untitled](./image/3/Untitled%206.png)

## [http://localhost:5601/app/dev_tools#/console](http://localhost:5601/app/dev_tools#/console) 에서 쿼리는 나오는데 Spring 통해서 실행이 안될 경우

---

- [http://localhost:9200/_cluster/health/?level=shards](http://localhost:9200/_cluster/health/?level=shards) 확인했는데 `status` 값이 yellow 일 것이다. 그럴 때 아래와 같이 replicas 수 0으로 만들어주면 green 으로 변경된다.
    
    ```powershell
    curl -XPUT -H 'Content-Type: application/json' 'localhost:9200/_settings' -d '{
        "index" : {
            "number_of_replicas" : 0
        }
    }'
    ```
    
- 위의 `health` 결과 `yellow`도 `green`으로 바뀐다.

## 로컬에서 ES 쿼리 실행시

---

- 헤더 붙여줘야 함
    
    ```powershell
    curl -H 'Content-Type: application/json' -iX POST 'http://localhost:9200/trade-history/_search?typed_keys=true&search_type=query_then_fetch' -d '{"from":0,"query":{"bool":{"must":[{"query_string":{"default_operator":"and","fields":["buyerId"],"query":"2"}},{"query_string":{"default_operator":"and","fields":["orderStatus"],"query":"\\-10"}}]}},"size":20,"track_scores":false,"version":true}'
    ```
