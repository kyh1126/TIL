# Chapter 16. 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
    - 시스템의 유스케이스
    - 시스템의 운영
    - 시스템의 개발
    - 시스템의 배포

## 유스케이스

---

- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
    - 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

- 행위는 일급 요소이며 시스템의 최상위 수준에서 알아볼 수 있으므로, 개발자가 일일이 찾아 헤매지 않아도 된다.
    - 요소는 클래스이거나 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지할 뿐만 아니라, 자신의 기능을 분명하게 설명하는 이름을 가질 것이다.

## 운영

---

- 시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.
    - 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

## 개발

---

- 아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.
- 콘웨이의 법칙: 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

## 배포

---

- 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다.
    - 목표는 ‘즉각적인 배포’

- 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
    - 이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.

## 선택사항 열어놓기

---

- 좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

## 계층 결합 분리

---

- 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다.

## 유스케이스 결합 분리

---

- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.

## 결합 분리 모드

---

- 우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야 한다.
    - 서비스 지향 아키텍처(service-oriented architecture): 서비스에 기반한 아키텍처
- 좋은 아키텍처는 선택권을 열어 둔다.
    - 결합 분리 모드는 이러한 선택지 중 하나다.

## 개발 독립성

---

- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다.
    - 기능 팀, 컴포넌트 팀, 혹은 또 다른 형태의 팀이라도, 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.

## 배포 독립성

---

- 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.
    - 실제로 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체(hot-swap)할 수 있다.

## 중복

---

- 소프트웨어에서 중복은 일반적으로 나쁜 것이다.
- 하지만 중복에도 여러 종류가 있다.
    - 진짜 중복
        - 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다.
    - 거짓된 또는 우발적인 중복
        - 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.

- 자동반사적으로 중복을 제거해버리는 잘못을 저지르는 유혹을 떨쳐내라.
    - 중복이 진짜 중복인지 확인하라.

## 결합 분리 모드(다시)

---

- 소스 코드 수준에서 분리할 수도 있으며, 바이너리 코드(배포) 수준에서도, 그리고 실행 단위(서비스) 수준에서도 분리할 수 있다.
    - 소스 수준 분리 모드
        - 소스 코드 모듈 사이의 의존성을 제어할 수 있다.
        - 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 때는 간단한 함수 호출을 사용한다. 컴퓨터 메모리에는 하나의 실행 파일만이 로드된다.
        - 흔히 모노리틱 구조라고 부른다.
    - 배포 수준 분리 모드
        - `jar` 파일, `DLL`, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다.
        - 많은 컴포넌트가 여전히 같은 주소 공간에 상주하며, 단순한 함수 호출을 통해 통신할 수 있다.
        - 어떤 컴포넌트는 동일한 프로세서의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓, 또는 공유 메모리를 통해 통신할 수 있다.
    - 서비스 수준 분리 모드
        - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.
        - 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다(ex> 서비스 또는 마이크로서비스)

- 좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.
    - 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.
    - 좋은 아키텍처라면 나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수도 있어야 한다.

## 결론

---

- 시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다.