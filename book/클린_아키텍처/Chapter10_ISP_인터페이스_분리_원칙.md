# Chapter 10. ISP: 인터페이스 분리 원칙

![10-1. 인터페이스 분리 원칙](Chapter%2010%20ISP%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%208e7345110e294e09976eb9d8379e9364/Untitled.png)

10-1. 인터페이스 분리 원칙

- 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.
    
    ![10-2. 분리된 오퍼레이션](Chapter%2010%20ISP%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%208e7345110e294e09976eb9d8379e9364/Untitled%201.png)
    
    10-2. 분리된 오퍼레이션
    

## ISP와 언어

---

- 정적 타입 언어는 사용자가 `import`, `use` 또는 `include`와 같은 타입 선언문을 사용하도록 강제한다.
    - 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.
- 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유는 바로 이 때문이다.
    - 동적 타입 언어에서는 소스 코드에 이러한 선언문이 존재하지 않는다.
    - 대신 런타임에 추론이 발생한다.

## ISP와 아키텍처

---

- 일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
    - 소스 코드 의존성의 경우 이는 분명한 사실
        - 불필요한 재컴파일과 재배포를 강제하기 때문이다.
    - 고수준인 아키텍처 수준에서도 마찬가지 상황
        - ex>  S 시스템 구축
            - 아키텍트는 F라는 프레임워크를 시스템에 도입하기를 원한다.
            - F 프레임워크 개발자는 특정한 D 데이터베이스를 반드시 사용하도록 만들었다.
            - S는 F에 의존하며, F는 다시 D에 의존하게 된다.
                
                ![10-3. 문제가 있는 아키텍처](Chapter%2010%20ISP%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%208e7345110e294e09976eb9d8379e9364/Untitled%202.png)
                
                10-3. 문제가 있는 아키텍처
                
            
            → D 내부의 기능 중 F와 S에서 불필요한 그 기능에 문제가 발생해도 F와 S에 영향을 준다.
            

## 결론

---

- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.